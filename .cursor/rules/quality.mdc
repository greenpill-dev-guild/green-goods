---
description: Code quality standards, testing expectations, and tooling conventions for Green Goods
globs:
alwaysApply: true
---

# Code Quality & Testing Standards

## Coding Principles

### Core Principles (Always Apply)

**DRY (Don't Repeat Yourself)**
- If you're writing similar code a third time, extract it to `@green-goods/shared`
- Use existing utilities: `queryKeys`, toast presets, date formatters
- Never hardcode values that exist in deployment artifacts

**KISS (Keep It Simple, Stupid)**
- Prefer simple, readable solutions over clever abstractions
- Use the simplest tool that solves the problem
- Don't add configuration for "just in case" scenarios

**YAGNI (You Ain't Gonna Need It)**
- Don't implement features until they're needed
- Don't add backwards-compatibility shims — change the code directly
- Delete unused code completely (no `_unused` prefixes)

### Code Design Principles

**Single Responsibility**
- Each function/component does one thing well
- If a component needs "and" in its description, split it

**Open/Closed**
- Extend behavior through composition, not modification
- Add new query keys without changing existing ones

**Boy Scout Rule**
- Leave code better than you found it
- Fix nearby typos, improve variable names while working

**Optimize for Deletion**
- Design modules that are easy to remove
- Loose coupling enables clean removal
- If it's hard to delete, it's too entangled

### Self-Documenting Code

```typescript
// ✅ Self-documenting — names explain intent
const isOffline = useOffline();
const { addGardener, removeGardener } = useGardenOperations();
await queryClient.invalidateQueries({ queryKey: queryKeys.works.merged(gardenId, chainId) });

// ❌ Cryptic — requires comments to understand
const o = useO();
const { a, r } = useGO();
await qc.inv({ qk: ['w', 'm', gid, cid] });
```

**Comments explain "why", code explains "how":**
```typescript
// Merge online and offline works, preferring online within 5-minute window
// to handle race conditions during sync
export async function mergeWorks(online: Work[], offline: Job[]): Promise<Work[]>
```

## Advanced TypeScript Patterns (2026)

### Never Use `any` — Use `unknown`

```typescript
// ✅ Forces type checking before use
function processData(data: unknown) {
  if (typeof data === 'string') {
    return data.toUpperCase();  // Safe - TypeScript knows it's string
  }
  if (isWork(data)) {
    return data.title;  // Safe - type guard narrows the type
  }
}

// ❌ Turns off compiler benefits
function processData(data: any) {
  return data.whatever;  // No safety!
}
```

### Discriminated Unions for Type-Safe Logic

```typescript
// ✅ Tagged unions with exhaustive checking
type AuthState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'authenticated'; user: User }
  | { status: 'error'; message: string };

function render(state: AuthState) {
  switch (state.status) {
    case 'idle': return <LoginButton />;
    case 'loading': return <Spinner />;
    case 'authenticated': return <Dashboard user={state.user} />;
    case 'error': return <Error message={state.message} />;
    default: {
      const _exhaustive: never = state;  // Compile error if case missed
      return _exhaustive;
    }
  }
}
```

### Strict Immutability with `as const`

```typescript
// ✅ Literal, read-only types
const CHAIN_IDS = {
  arbitrum: 42161,
  celo: 42220,
  baseSepolia: 84532,
} as const;

type ChainId = typeof CHAIN_IDS[keyof typeof CHAIN_IDS];  // 42161 | 42220 | 84532

// ❌ Without as const - loses literal types
const CHAIN_IDS = {
  arbitrum: 42161,  // Type: number (not 42161)
};
```

### AbortSignals for Async Safety

```typescript
// ✅ Cancellable async operations
async function fetchGardens(chainId: number, signal?: AbortSignal) {
  const response = await fetch(`/api/gardens?chain=${chainId}`, { signal });
  if (signal?.aborted) return [];
  return response.json();
}

// Usage in React
useEffect(() => {
  const controller = new AbortController();
  fetchGardens(chainId, controller.signal);
  return () => controller.abort();  // Cancel on unmount
}, [chainId]);

// ❌ Fire-and-forget (memory leaks, stale data)
useEffect(() => {
  fetchGardens(chainId);  // Can't cancel!
}, [chainId]);
```

### Type-Safe API Layers with Zod

```typescript
// ✅ Runtime validation + TypeScript inference
import { z } from 'zod';

const WorkSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1),
  status: z.enum(['pending', 'approved', 'rejected']),
});

type Work = z.infer<typeof WorkSchema>;  // Auto-inferred type!

function parseWork(data: unknown): Work {
  return WorkSchema.parse(data);  // Throws if invalid
}
```

### Avoid Magic Abstractions

```typescript
// ✅ Transparent, debuggable code
export function useGardenOperations() {
  const queryClient = useQueryClient();
  const chainId = useCurrentChain();

  const addGardener = async (gardenId: string, address: string) => {
    // Clear what happens, easy to debug
    await writeContract({ ... });
    queryClient.invalidateQueries({ queryKey: queryKeys.gardens.detail(gardenId, chainId) });
  };

  return { addGardener };
}

// ❌ Over-abstracted "clever" code
export const useGardenOperations = createMagicHook({
  mutations: ['addGardener', 'removeGardener'],
  autoInvalidate: true,
  globalErrorHandler: true,
});  // What does this do? How do I debug it?
```

### Top-Level Await for Module Init

```typescript
// ✅ Clean module initialization (ES2022+)
const config = await loadConfig();
export const client = createClient(config);

// ❌ Old pattern with IIFEs
let client: Client;
(async () => {
  const config = await loadConfig();
  client = createClient(config);
})();
export { client };  // May be undefined!
```

## Tooling Stack

### Biome (Formatting)

Fast formatter (35x faster than Prettier). Linting disabled at root — use oxlint.

```bash
bun format              # Format all files
bun format:check        # Check without writing
```

**Config:** `/biome.json` — 100 char line width, double quotes, ES5 trailing commas.

### oxlint (Linting)

Rust-based linter (~30ms on entire codebase).

```bash
bun lint                # Lint all packages
```

**Catches:** Unused variables, import issues, TypeScript errors, common mistakes.

### Combined Workflow

```bash
# Pre-commit (automatic via lint-staged)
bun format && bun lint

# Full validation
bun format && bun lint && bun test
```

## Conventional Commits

```
<type>(<scope>): <description>
```

**Types:** `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

**Scopes:** `client`, `admin`, `shared`, `contracts`, `indexer`, `agent`, or feature areas (`offline`, `auth`, `deployment`)

**Examples:**
```bash
feat(client): add offline work submission queue
fix(contracts): fix storage gap in GardenToken upgrade
test(shared): add job queue integration tests
```

## Testing Standards

### Coverage Targets

| Package | Critical Paths | Overall | Notes |
|---------|---------------|---------|-------|
| Client | 80%+ | 70%+ | 100% for auth/encryption |
| Admin | 70%+ | 70%+ | 100% for access control |
| Shared | 80%+ | 70%+ | Core logic, all hooks |
| Contracts | 100% (mainnet) | 80% (testnet) | Gas tests required |

### Test Organization

**TypeScript packages (Vitest):**
```
src/__tests__/
├── components/      # Component tests
├── hooks/           # Hook tests
├── modules/         # Service layer tests
└── integration/     # Multi-component flows
```

**Contracts (Foundry):**
```
test/
├── {Contract}.t.sol     # Unit tests
├── E2EWorkflow.t.sol    # Integration tests
└── helpers/             # Test utilities
```

### Test Naming

```typescript
// TypeScript: describe('[Module]') + it('[behavior]')
describe('JobQueue', () => {
  it('retries failed jobs with exponential backoff', async () => {});
});
```

```solidity
// Solidity: test[ContractName]_[scenario]
function testGardenToken_revertsOnUnauthorizedMint() public {}
```

## Code Style

### TypeScript Strictness

All packages use strict mode. **Never use `any`** — use `unknown` for untrusted data.

### Import Organization (Auto-sorted by Biome)

```typescript
// 1. External deps  2. Internal (@/ alias)  3. Relative  4. Types
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/Button';
import { helper } from './helper';
import type { Work } from '@/types';
```

### File Naming

- Components: `ComponentName.tsx`
- Hooks: `useFeatureName.ts`
- Tests: `*.test.ts(x)`
- Directories: lowercase (`hooks/auth/`, `modules/job-queue/`)

### Solidity

```bash
cd packages/contracts && forge fmt     # Format
cd packages/contracts && bun run lint  # Lint (solhint)
```

Use custom errors over require strings. Always include storage gaps in upgradeable contracts.

## Documentation Standards

**Required JSDoc for:** Exported functions, complex algorithms, public APIs.

```typescript
/**
 * Merges online and offline work submissions, deduplicating by content hash.
 * Online works take precedence within a 5-minute time window.
 */
export async function mergeWorks(online: Work[], offline: Job[]): Promise<Work[]>
```

## Pre-merge Requirements

- [ ] All tests passing (`bun test`)
- [ ] No lint errors (`bun lint`)
- [ ] Build succeeds (`bun build`)
- [ ] Conventional commit format
- [ ] README updated if needed

## Agent Validation Protocol

**MANDATORY:** Run validation after ANY code modification before reporting completion.

### Package-Specific Commands

**Client:**
```bash
cd packages/client && bun run build && bun run lint && bun run test
```

**Admin:**
```bash
cd packages/admin && bun run build && bun run lint && bun run test
```

**Shared:**
```bash
cd packages/shared && npx tsc --noEmit && bun run lint && bun run test
```

**Contracts:**
```bash
cd packages/contracts && bun run build && bun run lint && bun run test
```

**Indexer:**
```bash
cd packages/indexer && bun run build && bun run lint && bun run test
```

**Agent:**
```bash
cd packages/agent && bun run build && bun run test
```

### Validation by Task Type

| Task | Required |
|------|----------|
| New feature | `build` + `lint` + `test` |
| Bug fix | `build` + `lint` + affected tests |
| Refactor | `build` + `lint` + `test` |
| Type changes | `build` + `lint` |
| Config change | `build` |
| Docs only | `bun format` |

### Cross-Package Changes

Validate ALL affected packages. Example for shared → client:

```bash
cd packages/shared && npx tsc --noEmit && bun run lint && bun run test
cd packages/client && bun run build && bun run lint && bun run test
```

### Quick Validation (Minimum)

```bash
cd packages/{package} && bun run build && bun run lint
```

### On Failure

1. **Do NOT** report task complete
2. Read error output
3. Fix all errors
4. Re-run validation
5. Repeat until all pass

## Reference Documents

- Biome config: `/biome.json`
- Package rules: `packages/*/.cursor/rules/*.mdc`
- Architecture: `/docs/ARCHITECTURE.md`
