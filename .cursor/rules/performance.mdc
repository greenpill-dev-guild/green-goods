---
description: Performance optimization patterns for React, bundle size, and runtime efficiency
globs:
alwaysApply: true
---

# Performance Optimization Patterns

Performance standards for fast load times, smooth interactions, and efficient resource usage.

## Web Vitals Targets

| Metric | Target | Description |
|--------|--------|-------------|
| **LCP** | < 2.5s | Largest Contentful Paint — main content visible |
| **FID** | < 100ms | First Input Delay — time to interactive |
| **CLS** | < 0.1 | Cumulative Layout Shift — visual stability |
| **TTFB** | < 600ms | Time to First Byte — server response |
| **INP** | < 200ms | Interaction to Next Paint — responsiveness |

## Bundle Size Budgets

| Bundle | Budget (gzipped) | Notes |
|--------|------------------|-------|
| **Main bundle** | < 150KB | Critical path JS |
| **Per-route chunk** | < 50KB | Lazy-loaded routes |
| **Total JS** | < 400KB | All JavaScript |
| **Total CSS** | < 50KB | All styles |
| **Largest asset** | < 200KB | Any single file |

**Monitor with:**
```bash
# Vite bundle analyzer
bun --filter client build -- --report

# Check bundle sizes
ls -la packages/client/dist/assets/*.js | awk '{print $5, $9}'
```

## React Rendering Optimization

### When to Use useMemo

```typescript
// ✅ DO: Expensive computations
const sortedWorks = useMemo(
  () => works.sort((a, b) => b.createdAt - a.createdAt),
  [works]
);

// ✅ DO: Complex filtering
const filteredGardens = useMemo(
  () => gardens.filter(g => g.operators.includes(userId) && g.status === "active"),
  [gardens, userId]
);

// ✅ DO: Object creation passed to memoized children
const chartData = useMemo(
  () => works.map(w => ({ x: w.createdAt, y: w.value })),
  [works]
);

// ❌ DON'T: Simple values
const isOnline = useMemo(() => navigator.onLine, []);  // Overkill

// ❌ DON'T: Primitives
const count = useMemo(() => items.length, [items]);  // items.length is fine
```

### When to Use useCallback

```typescript
// ✅ DO: Callbacks passed to memoized children
const handleApprove = useCallback((workId: string) => {
  approveMutation.mutate(workId);
}, [approveMutation]);

// ✅ DO: Callbacks in dependency arrays
const handleSubmit = useCallback(async (data: FormData) => {
  await submitWork(data);
}, [submitWork]);

// Used in effect
useEffect(() => {
  document.addEventListener("keydown", handleSubmit);
  return () => document.removeEventListener("keydown", handleSubmit);
}, [handleSubmit]);

// ❌ DON'T: Inline handlers that don't cause re-renders
<button onClick={() => setOpen(true)}>  // Fine without useCallback
```

### When to Use React.memo

```typescript
// ✅ DO: Components receiving stable primitive props
export const WorkCard = memo(function WorkCard({ work }: { work: Work }) {
  return <div>...</div>;
});

// ✅ DO: Components in lists
export const GardenListItem = memo(function GardenListItem({ garden }: Props) {
  return <li>...</li>;
});

// ❌ DON'T: Components that always receive new object props
// (unless you also memoize the props)
const Parent = () => {
  // This creates new object every render, defeating memo
  return <MemoizedChild data={{ foo: "bar" }} />;
};
```

### Avoid Unnecessary Re-renders

```typescript
// ❌ Wrong — creates new object every render
function Parent() {
  return <Child style={{ color: "red" }} />;
}

// ✅ Correct — stable reference
const childStyle = { color: "red" };
function Parent() {
  return <Child style={childStyle} />;
}

// Or with useMemo if dynamic
function Parent({ isActive }) {
  const style = useMemo(() => ({ color: isActive ? "green" : "red" }), [isActive]);
  return <Child style={style} />;
}
```

## Code Splitting

### Route-Based Splitting (Already Implemented)

```typescript
// Routes are already lazy-loaded
const GardenView = lazy(() => import("./views/Garden"));
const WorkView = lazy(() => import("./views/Work"));

// With loading fallback
<Suspense fallback={<PageSkeleton />}>
  <Routes>
    <Route path="/garden/:id" element={<GardenView />} />
  </Routes>
</Suspense>
```

### Component-Based Splitting

```typescript
// Heavy components that aren't always needed
const ImageEditor = lazy(() => import("./components/ImageEditor"));
const ChartWidget = lazy(() => import("./components/ChartWidget"));

// Load on demand
{showEditor && (
  <Suspense fallback={<Spinner />}>
    <ImageEditor />
  </Suspense>
)}
```

### Library Splitting

```typescript
// Dynamic import for heavy libraries
async function processImage(file: File) {
  const { compress } = await import("browser-image-compression");
  return compress(file, { maxSizeMB: 1 });
}

// Don't import at top level
// ❌ import { compress } from "browser-image-compression";
```

## List Virtualization

**For lists > 50 items, use virtualization:**

```typescript
import { useVirtualizer } from "@tanstack/react-virtual";

function WorkList({ works }: { works: Work[] }) {
  const parentRef = useRef<HTMLDivElement>(null);

  const virtualizer = useVirtualizer({
    count: works.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 72,  // Estimated row height
    overscan: 5,
  });

  return (
    <div ref={parentRef} className="h-[600px] overflow-auto">
      <div
        style={{
          height: `${virtualizer.getTotalSize()}px`,
          position: "relative",
        }}
      >
        {virtualizer.getVirtualItems().map((virtualRow) => (
          <div
            key={virtualRow.key}
            style={{
              position: "absolute",
              top: 0,
              transform: `translateY(${virtualRow.start}px)`,
              height: `${virtualRow.size}px`,
            }}
          >
            <WorkCard work={works[virtualRow.index]} />
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Image Optimization

### Compression Before Upload

```typescript
import imageCompression from "browser-image-compression";

async function compressImage(file: File): Promise<File> {
  const options = {
    maxSizeMB: 1,              // Max file size
    maxWidthOrHeight: 1920,    // Max dimensions
    useWebWorker: true,        // Off main thread
    fileType: "image/webp",    // Modern format
  };

  return imageCompression(file, options);
}
```

### Lazy Loading Images

```typescript
// Native lazy loading
<img src={url} alt={alt} loading="lazy" />

// With placeholder
function LazyImage({ src, alt }: { src: string; alt: string }) {
  const [loaded, setLoaded] = useState(false);

  return (
    <div className="relative">
      {!loaded && <div className="skeleton absolute inset-0" />}
      <img
        src={src}
        alt={alt}
        loading="lazy"
        onLoad={() => setLoaded(true)}
        className={loaded ? "opacity-100" : "opacity-0"}
      />
    </div>
  );
}
```

### Responsive Images

```typescript
// srcset for different screen sizes
<img
  src={image.url}
  srcSet={`
    ${image.small} 400w,
    ${image.medium} 800w,
    ${image.large} 1200w
  `}
  sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
  alt={image.alt}
  loading="lazy"
/>
```

## Data Fetching Optimization

### Prefetching

```typescript
// Prefetch on hover
function GardenLink({ gardenId }: { gardenId: string }) {
  const queryClient = useQueryClient();

  const prefetch = () => {
    queryClient.prefetchQuery({
      queryKey: queryKeys.gardens.detail(gardenId, chainId),
      queryFn: () => fetchGarden(gardenId),
      staleTime: 60000,  // Only prefetch if stale
    });
  };

  return (
    <Link
      to={`/garden/${gardenId}`}
      onMouseEnter={prefetch}
      onFocus={prefetch}
    >
      View Garden
    </Link>
  );
}
```

### Parallel Queries

```typescript
// ✅ Parallel — both start immediately
const gardensQuery = useQuery({ queryKey: queryKeys.gardens.all(chainId), ... });
const actionsQuery = useQuery({ queryKey: queryKeys.actions.all(chainId), ... });

// Or with useQueries
const results = useQueries({
  queries: [
    { queryKey: queryKeys.gardens.all(chainId), queryFn: fetchGardens },
    { queryKey: queryKeys.actions.all(chainId), queryFn: fetchActions },
  ],
});
```

### Stale Time Configuration

```typescript
// Configure based on data volatility
const STALE_TIMES = {
  STATIC: 1000 * 60 * 60,    // 1 hour — rarely changes (actions, schemas)
  GARDEN: 1000 * 60 * 5,      // 5 min — moderate changes
  WORK: 1000 * 60 * 2,        // 2 min — changes more frequently
  QUEUE: 1000 * 30,           // 30 sec — real-time important
};

useQuery({
  queryKey: queryKeys.actions.all(chainId),
  queryFn: fetchActions,
  staleTime: STALE_TIMES.STATIC,
});
```

## IndexedDB Performance

### Batch Operations

```typescript
// ❌ Slow — individual operations
for (const job of jobs) {
  await db.put("jobs", job);
}

// ✅ Fast — batch in single transaction
const tx = db.transaction("jobs", "readwrite");
const store = tx.objectStore("jobs");
await Promise.all(jobs.map(job => store.put(job)));
await tx.done;
```

### Index Usage

```typescript
// Define indexes for common queries
const db = await openDB("green-goods", 1, {
  upgrade(db) {
    const jobStore = db.createObjectStore("jobs", { keyPath: "id" });
    jobStore.createIndex("status", "status");
    jobStore.createIndex("gardenId", "gardenId");
    jobStore.createIndex("createdAt", "createdAt");
  },
});

// Query using index
const pendingJobs = await db.getAllFromIndex("jobs", "status", "pending");
```

### Cursor for Large Datasets

```typescript
// Don't load everything into memory
async function* iterateJobs(db: IDBDatabase) {
  const tx = db.transaction("jobs", "readonly");
  const store = tx.objectStore("jobs");
  let cursor = await store.openCursor();

  while (cursor) {
    yield cursor.value;
    cursor = await cursor.continue();
  }
}

// Process one at a time
for await (const job of iterateJobs(db)) {
  await processJob(job);
}
```

## Service Worker Caching

### Cache Strategy by Resource Type

```typescript
// sw.ts
import { registerRoute } from "workbox-routing";
import { CacheFirst, NetworkFirst, StaleWhileRevalidate } from "workbox-strategies";

// Static assets — cache first
registerRoute(
  ({ request }) => request.destination === "image" ||
                   request.destination === "font" ||
                   request.destination === "style",
  new CacheFirst({
    cacheName: "static-assets",
    plugins: [
      new ExpirationPlugin({ maxEntries: 100, maxAgeSeconds: 30 * 24 * 60 * 60 }),
    ],
  })
);

// API data — network first with cache fallback
registerRoute(
  ({ url }) => url.pathname.startsWith("/api/"),
  new NetworkFirst({
    cacheName: "api-cache",
    plugins: [
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 5 * 60 }),
    ],
  })
);

// HTML — stale while revalidate
registerRoute(
  ({ request }) => request.mode === "navigate",
  new StaleWhileRevalidate({
    cacheName: "pages",
  })
);
```

## Animation Performance

### Use CSS Transforms

```typescript
// ✅ GPU-accelerated (transform, opacity)
<div className="transition-transform duration-300 hover:scale-105" />

// ❌ Triggers layout (width, height, top, left)
<div className="transition-all duration-300 hover:w-[200px]" />
```

### Respect Reduced Motion

```typescript
// CSS
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    transition-duration: 0.01ms !important;
  }
}

// JavaScript
const prefersReducedMotion = window.matchMedia(
  "(prefers-reduced-motion: reduce)"
).matches;

if (!prefersReducedMotion) {
  // Run animation
}
```

### Debounce Expensive Operations

```typescript
import { useDebouncedCallback } from "use-debounce";

function SearchInput() {
  const [query, setQuery] = useState("");

  // Debounce search to avoid excessive API calls
  const debouncedSearch = useDebouncedCallback(
    (value: string) => {
      searchMutation.mutate(value);
    },
    300  // 300ms delay
  );

  return (
    <input
      value={query}
      onChange={(e) => {
        setQuery(e.target.value);
        debouncedSearch(e.target.value);
      }}
    />
  );
}
```

## Memory Management

### Cleanup Subscriptions

```typescript
useEffect(() => {
  const subscription = eventBus.on("event", handler);

  return () => {
    subscription.unsubscribe();  // Always cleanup!
  };
}, []);
```

### Revoke Object URLs

```typescript
// Create blob URL
const url = URL.createObjectURL(file);

// MUST revoke when done
useEffect(() => {
  return () => {
    URL.revokeObjectURL(url);
  };
}, [url]);

// Or use mediaResourceManager from shared
const url = mediaResourceManager.createTrackedURL(file, "work-draft");
// Auto-cleaned by tracking ID
```

### Abort Pending Requests

```typescript
useEffect(() => {
  const controller = new AbortController();

  fetchData({ signal: controller.signal });

  return () => {
    controller.abort();  // Cancel on unmount
  };
}, []);
```

## Performance Testing

### Lighthouse CI

```yaml
# .github/workflows/lighthouse.yml
- name: Lighthouse
  uses: treosh/lighthouse-ci-action@v10
  with:
    urls: |
      https://preview-${{ github.event.pull_request.number }}.vercel.app
    budgetPath: ./lighthouse-budget.json
```

### Bundle Analysis

```bash
# Analyze bundle
bun --filter client build -- --report

# Check for duplicates
npx bundle-buddy packages/client/dist/assets/*.js
```

### React DevTools Profiler

```typescript
// Wrap components to profile
import { Profiler } from "react";

<Profiler id="WorkList" onRender={onRenderCallback}>
  <WorkList works={works} />
</Profiler>

function onRenderCallback(
  id: string,
  phase: "mount" | "update",
  actualDuration: number,
  baseDuration: number,
) {
  if (actualDuration > 16) {  // > 1 frame
    console.warn(`Slow render: ${id} took ${actualDuration}ms`);
  }
}
```

## Anti-Patterns

### Never Block the Main Thread

```typescript
// ❌ Blocks main thread
const result = heavyComputation(largeData);

// ✅ Use Web Worker
const worker = new Worker("./heavy-worker.ts");
worker.postMessage(largeData);
worker.onmessage = (e) => setResult(e.data);
```

### Never Create Objects in Render

```typescript
// ❌ New object every render
function Component() {
  return <Child options={{ foo: "bar" }} />;
}

// ✅ Stable reference
const options = { foo: "bar" };
function Component() {
  return <Child options={options} />;
}
```

### Never Fetch in Render Without Caching

```typescript
// ❌ Infinite loop
function Component() {
  const [data, setData] = useState(null);
  fetch("/api/data").then(r => r.json()).then(setData);
  // ...
}

// ✅ Use TanStack Query
function Component() {
  const { data } = useQuery({ queryKey: ["data"], queryFn: fetchData });
}
```

## Reference

- Bundle analysis: `bun --filter client build -- --report`
- Web Vitals: https://web.dev/vitals/
- React profiler: https://react.dev/reference/react/Profiler
