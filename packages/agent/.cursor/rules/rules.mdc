# Green Goods Agent — Core Patterns & Conventions

The agent package provides a platform-agnostic bot for Green Goods, currently supporting Telegram with architecture designed for Discord, WhatsApp, and SMS.

## Architecture Philosophy

### Flat & Simple Architecture

The agent uses a minimal, flat structure optimized for the current scale:

```
src/
├── types.ts           # All shared types
├── index.ts           # Entry point
├── config.ts          # Configuration
│
├── handlers/          # Pure business logic
│   ├── index.ts       # Message router
│   ├── start.ts       # /start command
│   ├── join.ts        # /join command
│   └── ...
│
├── services/          # External integrations (singletons)
│   ├── db.ts          # SQLite storage
│   ├── blockchain.ts  # Viem operations
│   ├── ai.ts          # Whisper STT
│   ├── crypto.ts      # Encryption
│   └── rate-limiter.ts
│
├── platforms/         # Platform adapters
│   └── telegram.ts    # Telegram bot + transformer
│
└── api/               # HTTP server
    └── server.ts      # Fastify
```

**Why:** Simple, easy to understand, minimal indirection. Add complexity only when scale demands it.

## Key Patterns

### 1. Handler Structure

All handlers are **pure functions** that take a message and minimal dependencies:

```typescript
export interface StartDeps {
  generatePrivateKey: () => `0x${string}`;
}

export async function handleStart(
  message: InboundMessage,
  deps: StartDeps
): Promise<HandlerResult> {
  const user = await db.getUser(message.platform, message.sender.platformId);
  
  if (!user) {
    const privateKey = deps.generatePrivateKey();
    // ... create user
  }
  
  return {
    response: { text: 'Welcome!' },
  };
}
```

**Pattern Rules:**
- Import services directly (no dependency injection)
- Only inject functions that need mocking (generatePrivateKey, etc.)
- Return structured `HandlerResult`
- Use centralized types from `types.ts`

### 2. Platform-Agnostic Messages

All platforms normalized to common format:

```typescript
interface InboundMessage {
  id: string;
  platform: 'telegram' | 'discord' | 'whatsapp' | 'sms';
  sender: { platformId: string; displayName?: string };
  content: MessageContent;  // text | command | voice | callback | image
  locale?: string;
  timestamp: number;
}
```

**Transformers** in platform files:
```typescript
// platforms/telegram.ts
export function toInboundMessage(ctx: TelegramContext): InboundMessage | null
export function toTelegramReply(response: OutboundResponse): TelegramFormat
```

### 3. Session Management

Sessions track multi-step flows (work submission, confirmations):

```typescript
// In handler result
return {
  response: { text: 'Confirm your work?', buttons: [...] },
  updateSession: { step: 'confirming_work', draft: workData },
};

// Clear session when done
return {
  response: { text: 'Submitted!' },
  clearSession: true,
};
```

**Session data stored in SQLite** and keyed by `(platform, platformId)`.

### 4. Rate Limiting

Rate limits checked per action type via sliding window:

```typescript
import { rateLimiter } from './services/rate-limiter';

const result = rateLimiter.check(platformId, 'submission');
if (!result.allowed) {
  return textResponse(`⏳ ${result.message}`);
}
```

**Configured limits:**
- Messages: 10/min
- Voice: 3/min
- Submissions: 5 per 5min
- Commands: 20/min
- Approvals: 30/min

### 5. Service Singletons

Services initialized once at startup:

```typescript
// In index.ts
initDB(config.dbPath);
initBlockchain(config.chain);
initAI();

// In handlers - use directly
import * as db from '../services/db';
import * as blockchain from '../services/blockchain';

const user = await db.getUser(platform, platformId);
const gardenInfo = await blockchain.getGardenInfo(address);
```

### 6. Error Handling

Graceful degradation with user-friendly messages:

```typescript
try {
  await blockchain.submitWork(params);
} catch (error) {
  console.error('Submit error:', error);
  return {
    response: {
      text: 'Failed to submit work. Please try again later.',
    },
  };
}
```

## Development Workflow

### Adding a New Command

1. **Create handler** in `src/handlers/{command}.ts`
2. **Export** from `src/handlers/index.ts`
3. **Add route** in handler router (handleCommand switch)
4. **Write tests** in `src/__tests__/handlers.test.ts`
5. **Update** help text in `src/handlers/help.ts`

### Adding a New Platform

1. **Create adapter** in `src/platforms/{platform}.ts`
   - `toInboundMessage()` — Convert platform events
   - `toResponse()` — Convert outbound responses
   - `create{Platform}Bot()` — Bot setup
   - `createVoiceProcessor()` — If supporting voice
   - `createNotifier()` — For outbound messages
2. **Add webhook route** in `src/api/server.ts`
3. **Update entry point** (`src/index.ts`) to initialize adapter
4. **Write integration tests**

### Testing Requirements

- **Unit tests** for all handlers (pure functions, easy to test)
- **Integration tests** for storage, blockchain
- **Mock external dependencies** (Telegram API, blockchain)
- **Coverage target:** 80%+ overall, 100% for security-critical (crypto, rate limiting)

## Code Style

### TypeScript Strictness

All code uses strict TypeScript:
```json
{
  "strict": true,
  "noImplicitAny": true,
  "noUncheckedIndexedAccess": true
}
```

**Never use `any`** — Use `unknown` for untrusted data, type guards for narrowing.

### Import Organization

```typescript
// 1. External dependencies
import { Telegraf } from 'telegraf';
import type { Hex } from 'viem';

// 2. Internal imports
import * as db from '../services/db';
import { textResponse } from '../types';

// 3. Type-only imports
import type { InboundMessage, User } from '../types';
```

### File Naming

- **Handlers:** `src/handlers/{command}.ts`
- **Services:** `src/services/{name}.ts`
- **Tests:** `src/__tests__/{module}.test.ts`
- **Lowercase directories:** `handlers/`, `services/`, `platforms/`

## Security Practices

### Private Key Management

Keys are **encrypted at rest** using AES-256-GCM:

```typescript
import { prepareKeyForStorage, getPrivateKey } from './services/crypto';

// Encrypt before storage
const encrypted = prepareKeyForStorage(privateKey);

// Decrypt when needed
const { privateKey, needsMigration } = getPrivateKey(storedKey);
```

### Input Validation

Validate all user inputs:

```typescript
import { isValidAddress, isValidPrivateKey } from './services/crypto';

if (!isValidAddress(input)) {
  return { response: { text: 'Invalid address format' } };
}
```

### Rate Limiting

Always check rate limits before expensive operations:

```typescript
const rateCheck = rateLimiter.check(platformId, 'submission');
if (!rateCheck.allowed) {
  return textResponse(`⏳ ${rateCheck.message}`);
}
```

## Configuration

All configuration from environment variables via `src/config.ts`:

```typescript
import { getConfig } from './config';

const config = getConfig();
// config.chain, config.telegramToken, etc.
```

**Chain configuration** uses `getDefaultChain()` from `@green-goods/shared`.

## Common Anti-Patterns

### ❌ Don't Put Business Logic in Platform Adapters

```typescript
// Wrong - business logic in Telegram adapter
bot.on('text', async (ctx) => {
  if (ctx.text.includes('plant')) {
    // ... parsing logic here
  }
});

// Correct - adapter only transforms, router handles
bot.on('text', async (ctx) => {
  const inbound = toInboundMessage(ctx);
  const response = await handleMessage(inbound);
  const { text, options } = toTelegramReply(response);
  await ctx.reply(text, options);
});
```

### ❌ Don't Skip Rate Limiting

```typescript
// Wrong
async handleVoice(message) {
  return await this.processVoice(message);
}

// Correct
async handleVoice(message) {
  const rateCheck = rateLimiter.check(message.sender.platformId, 'voice');
  if (!rateCheck.allowed) return textResponse(rateCheck.message);
  return await this.processVoice(message);
}
```

### ❌ Don't Hardcode Chain IDs

```typescript
// Wrong
const chainId = 84532;

// Correct
const config = getConfig();
const chainId = config.chainId;
```

## References

- **Architecture Details:** `AGENTS.md`
- **Testing Guide:** `.cursor/rules/testing.mdc`
- **Deployment Guide:** `.cursor/rules/deployment.mdc`
- **Security Patterns:** `.cursor/rules/security.mdc`
- **Package README:** `README.md`
