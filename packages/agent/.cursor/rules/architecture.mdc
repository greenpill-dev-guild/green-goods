# Agent Architecture Deep Dive

Detailed architecture patterns for the Green Goods agent package.

## Flat Architecture

### Core Principle

**Keep it simple until complexity is needed.**

```
src/
â”œâ”€â”€ types.ts           # All types in ONE place
â”œâ”€â”€ index.ts           # Entry point
â”œâ”€â”€ config.ts          # Configuration
â”‚
â”œâ”€â”€ handlers/          # Business logic (pure functions)
â”‚   â”œâ”€â”€ index.ts       # Message router
â”‚   â”œâ”€â”€ start.ts       # User registration
â”‚   â”œâ”€â”€ join.ts        # Garden membership
â”‚   â”œâ”€â”€ status.ts      # User status
â”‚   â”œâ”€â”€ help.ts        # Help text
â”‚   â”œâ”€â”€ pending.ts     # Pending works (operator)
â”‚   â”œâ”€â”€ approve.ts     # Work approval
â”‚   â”œâ”€â”€ reject.ts      # Work rejection
â”‚   â”œâ”€â”€ submit.ts      # Work submission
â”‚   â””â”€â”€ utils.ts       # Handler utilities
â”‚
â”œâ”€â”€ services/          # External integrations
â”‚   â”œâ”€â”€ db.ts          # SQLite (singleton)
â”‚   â”œâ”€â”€ blockchain.ts  # Viem (singleton)
â”‚   â”œâ”€â”€ ai.ts          # Whisper (singleton)
â”‚   â”œâ”€â”€ crypto.ts      # Encryption utils
â”‚   â””â”€â”€ rate-limiter.ts # Rate limiting
â”‚
â”œâ”€â”€ platforms/         # Platform adapters
â”‚   â””â”€â”€ telegram.ts    # All Telegram code
â”‚
â””â”€â”€ api/
    â””â”€â”€ server.ts      # Fastify health + webhooks
```

### Why This Architecture

| Pattern | Benefit |
|---------|---------|
| **Types in one file** | Single source of truth, easy to find |
| **Services as singletons** | Simple initialization, no DI complexity |
| **Platform adapters** | Each platform in ONE file |
| **No interfaces** | Direct imports, less indirection |

### Trade-offs

**Pros:**
- Easy to understand
- Fast to navigate
- Minimal boilerplate
- Quick to add features

**Cons:**
- Services not mockable (use dependency injection for testable functions)
- Adding platforms requires some duplication
- Scaling may require refactoring

## Layer Breakdown

### 1. Types Layer

**Location:** `src/types.ts`

**All types in one file:**

```typescript
// Messages
export type Platform = "telegram" | "discord" | "whatsapp" | "sms";

export interface InboundMessage {
  id: string;
  platform: Platform;
  sender: { platformId: string; displayName?: string };
  content: MessageContent;
  locale?: string;
  timestamp: number;
}

export interface OutboundResponse {
  text: string;
  parseMode?: "markdown" | "html";
  buttons?: ResponseButton[];
}

// Users, sessions, pending work, blockchain types...
```

### 2. Handlers Layer

**Location:** `src/handlers/`

**Pure functions with minimal dependencies:**

```typescript
// handlers/start.ts
import * as db from "../services/db";
import type { InboundMessage, HandlerResult } from "../types";

export interface StartDeps {
  generatePrivateKey: () => `0x${string}`;
}

export async function handleStart(
  message: InboundMessage,
  deps: StartDeps
): Promise<HandlerResult> {
  const { platform, sender } = message;
  
  // Use db service directly
  const user = await db.getUser(platform, sender.platformId);
  
  if (!user) {
    const privateKey = deps.generatePrivateKey();
    await db.createUser({
      platform,
      platformId: sender.platformId,
      privateKey,
      address: privateKeyToAddress(privateKey),
    });
  }
  
  return { response: { text: "Welcome!" } };
}
```

**Message router (`handlers/index.ts`):**

```typescript
export async function handleMessage(message: InboundMessage): Promise<OutboundResponse> {
  const { platform, sender, content } = message;
  const user = await db.getUser(platform, sender.platformId);

  if (isCommandContent(content)) {
    return handleCommand(message, user);
  }
  if (isVoiceContent(content)) {
    return handleVoice(message, user);
  }
  if (isTextContent(content)) {
    return handleText(message, user);
  }
  
  return textResponse("Unsupported message type.");
}
```

### 3. Services Layer

**Location:** `src/services/`

**Singleton pattern - initialize once, use everywhere:**

```typescript
// services/db.ts
class DB {
  private db: Database;
  
  constructor(dbPath: string) {
    this.db = new Database(dbPath);
    this.initSchema();
  }
  
  async getUser(platform: Platform, platformId: string): Promise<User | undefined> {
    // ... implementation
  }
}

let _db: DB | null = null;

export function initDB(dbPath: string): DB {
  if (!_db) _db = new DB(dbPath);
  return _db;
}

export function getDB(): DB {
  if (!_db) throw new Error("DB not initialized");
  return _db;
}

// Convenience exports
export const getUser = (platform: Platform, platformId: string) => 
  getDB().getUser(platform, platformId);
```

**Usage in handlers:**

```typescript
import * as db from "../services/db";

const user = await db.getUser("telegram", "123456");
```

### 4. Platforms Layer

**Location:** `src/platforms/`

**One file per platform with:**
- Message transformation
- Response transformation
- Bot/client setup
- Voice processing (if supported)
- Notifications

```typescript
// platforms/telegram.ts

// Transform Telegram â†’ InboundMessage
export function toInboundMessage(ctx: Context): InboundMessage | null {
  // ... extract message content
}

// Transform OutboundResponse â†’ Telegram format
export function toTelegramReply(response: OutboundResponse) {
  // ... format for Telegram
}

// Voice processor
export function createVoiceProcessor(bot: Telegraf, transcribe: TranscribeFn) {
  return {
    async downloadAndTranscribe(fileId: string): Promise<string> {
      // Download, convert, transcribe
    },
  };
}

// Notifier for outbound messages
export function createNotifier(bot: Telegraf) {
  return {
    async notify(platform: string, platformId: string, message: string) {
      await bot.telegram.sendMessage(Number(platformId), message);
    },
  };
}

// Bot creation
export function createTelegramBot(config: TelegramConfig, handleMessage: MessageHandler) {
  const bot = new Telegraf(config.token);
  
  bot.on(message("text"), async (ctx) => {
    const inbound = toInboundMessage(ctx);
    const response = await handleMessage(inbound);
    const { text, options } = toTelegramReply(response);
    await ctx.reply(text, options);
  });
  
  return bot;
}
```

## Data Flow

### Inbound Message Flow

```
User sends message
         â”‚
         â–¼
Platform API (Telegram, Discord, etc.)
         â”‚
         â–¼
Platform adapter: toInboundMessage()
         â”‚
         â–¼
InboundMessage (platform-agnostic)
         â”‚
         â–¼
handleMessage() router
         â”‚
         â”œâ”€â”€ isCommandContent â†’ handleCommand()
         â”œâ”€â”€ isTextContent â†’ handleText()
         â”œâ”€â”€ isVoiceContent â†’ handleVoice()
         â””â”€â”€ isCallbackContent â†’ handleCallback()
         â”‚
         â–¼
Handler function (pure logic)
         â”‚
         â–¼
HandlerResult { response, updateSession?, clearSession? }
         â”‚
         â–¼
Platform adapter: toResponse()
         â”‚
         â–¼
User sees response
```

### Example: Work Submission

```typescript
// 1. User sends: "I planted 5 trees today"

// 2. Telegram adapter transforms
const inbound: InboundMessage = {
  id: "12345",
  platform: "telegram",
  sender: { platformId: "987654321" },
  content: { type: "text", text: "I planted 5 trees today" },
  timestamp: Date.now(),
};

// 3. Router delegates to handleText()
const response = await handleMessage(inbound);

// 4. Handler processes and returns
{
  response: {
    text: "Confirm your work?\n\nðŸ“ Task: planted 5 trees",
    buttons: [
      { label: "âœ… Submit", callbackData: "confirm_submission" },
      { label: "âŒ Cancel", callbackData: "cancel_submission" }
    ]
  },
  updateSession: {
    step: "confirming_work",
    draft: { tasks: [...], notes: "I planted 5 trees today" }
  }
}

// 5. Telegram adapter transforms response
await ctx.reply(response.text, {
  reply_markup: { inline_keyboard: [[...buttons]] }
});
```

## Handler Context

For platform-specific features (voice, notifications), use handler context:

```typescript
// handlers/index.ts
export interface HandlerContext {
  voiceProcessor?: {
    downloadAndTranscribe: (fileId: string) => Promise<string>;
  };
  notifier?: {
    notify: (platform: string, platformId: string, message: string) => Promise<void>;
  };
}

let _context: HandlerContext = {};

export function setHandlerContext(ctx: HandlerContext): void {
  _context = ctx;
}

// Usage in handlers
async function handleVoice(message: InboundMessage, user: User) {
  if (!_context.voiceProcessor) {
    return textResponse("Voice not supported");
  }
  
  const text = await _context.voiceProcessor.downloadAndTranscribe(
    (message.content as VoiceContent).audioUrl
  );
  // ... process transcription
}
```

## Testing Strategy

### Unit Tests (Handlers)

Handlers are pure functions - easy to test:

```typescript
describe("handleStart", () => {
  beforeAll(() => {
    initDB(":memory:");
  });

  it("creates new user", async () => {
    const message = createTestMessage({
      sender: { platformId: "new-user" },
      content: { type: "command", name: "start", args: [] },
    });

    const result = await handleStart(message, {
      generatePrivateKey: () => "0x" + "a".repeat(64),
    });

    expect(result.response.text).toContain("Welcome");
  });
});
```

### Integration Tests (Services)

Test with real dependencies:

```typescript
describe("SQLite Storage", () => {
  beforeAll(() => {
    initDB("data/test/test.db");
  });

  it("creates and retrieves user", async () => {
    await db.createUser({
      platform: "telegram",
      platformId: "123",
      privateKey: "0x...",
      address: "0xabc...",
    });

    const user = await db.getUser("telegram", "123");
    expect(user?.address).toBe("0xabc...");
  });
});
```

## Adding a New Platform (Discord Example)

1. **Create platform file:**

```typescript
// platforms/discord.ts
import { Client, GatewayIntentBits } from "discord.js";

export function toInboundMessage(message: DiscordMessage): InboundMessage | null {
  return {
    id: message.id,
    platform: "discord",
    sender: {
      platformId: message.author.id,
      displayName: message.author.username,
    },
    content: extractContent(message),
    timestamp: message.createdTimestamp,
  };
}

export function toDiscordReply(response: OutboundResponse) {
  // ... format for Discord
}

export function createDiscordBot(token: string, handleMessage: MessageHandler) {
  const client = new Client({ intents: [...] });
  
  client.on("messageCreate", async (msg) => {
    const inbound = toInboundMessage(msg);
    const response = await handleMessage(inbound);
    await msg.reply(toDiscordReply(response));
  });
  
  return client;
}
```

2. **Add webhook route:**

```typescript
// api/server.ts
case "discord":
  // Handle Discord interactions webhook
  break;
```

3. **Update entry point:**

```typescript
// index.ts
const discordBot = createDiscordBot(config.discordToken, handleMessage);
```

## Configuration

**Centralized in `src/config.ts`:**

```typescript
export interface Config {
  nodeEnv: string;
  chainId: number;
  chain: Chain;
  telegramToken: string;
  encryptionSecret?: string;
  mode: "polling" | "webhook";
  port: number;
  host: string;
  dbPath: string;
  // ...
}

export function getConfig(): Config {
  // Load and validate from environment
}
```

## References

- **Main docs:** `AGENTS.md`
- **Handler examples:** `src/handlers/`
- **Service implementations:** `src/services/`
- **Platform adapters:** `src/platforms/`
