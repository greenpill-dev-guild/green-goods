---
description: Agent architecture deep dive — data flow, handler context, layer patterns
globs:
  - src/**/*.ts
alwaysApply: false
---

# Agent Architecture Deep Dive

Detailed patterns for the Green Goods agent. See `AGENTS.md` for overview.

## Data Flow

```
User → Platform API → toInboundMessage() → handleMessage() router
                                                    │
                    ┌───────────────────────────────┼───────────────────────────────┐
                    ▼                               ▼                               ▼
            handleCommand()                  handleText()                   handleVoice()
                    │                               │                               │
                    └───────────────────────────────┼───────────────────────────────┘
                                                    ▼
                                    HandlerResult { response, updateSession? }
                                                    ▼
                                           toResponse() → Platform API → User
```

## Layer Patterns

### Types Layer (`types.ts`)

**All types in one file** — Single source of truth:

```typescript
export type Platform = "telegram" | "discord" | "whatsapp" | "sms";
export interface InboundMessage { ... }
export interface OutboundResponse { ... }
export interface HandlerResult { ... }
```

### Handlers Layer (`handlers/`)

**Pure functions with minimal dependencies:**

```typescript
// Inject only what needs mocking
export interface StartDeps {
  generatePrivateKey: () => `0x${string}`;
}

export async function handleStart(message: InboundMessage, deps: StartDeps): Promise<HandlerResult> {
  // Use services directly
  const user = await db.getUser(message.platform, message.sender.platformId);
  // ...
}
```

### Services Layer (`services/`)

**Singleton pattern:**

```typescript
let _db: DB | null = null;

export function initDB(path: string): DB {
  if (!_db) _db = new DB(path);
  return _db;
}

// Convenience exports
export const getUser = (platform: Platform, id: string) => getDB().getUser(platform, id);
```

### Platforms Layer (`platforms/`)

**One file per platform with all platform-specific code:**

- `toInboundMessage()` — Convert platform event → InboundMessage
- `toResponse()` — Convert OutboundResponse → platform format
- `create{Platform}Bot()` — Bot setup and lifecycle
- `createVoiceProcessor()` — Voice handling (if supported)
- `createNotifier()` — Outbound notifications

## Handler Context

For platform-specific features, use handler context:

```typescript
// handlers/index.ts
export interface HandlerContext {
  voiceProcessor?: { downloadAndTranscribe: (fileId: string) => Promise<string> };
  notifier?: { notify: (platform: string, id: string, msg: string) => Promise<void> };
}

let _context: HandlerContext = {};
export function setHandlerContext(ctx: HandlerContext): void { _context = ctx; }
```

## Adding a Platform

1. **Create `platforms/{platform}.ts`:**
   ```typescript
   export function toInboundMessage(event: PlatformEvent): InboundMessage | null { ... }
   export function toResponse(response: OutboundResponse): PlatformFormat { ... }
   export function createBot(config, handleMessage) { ... }
   ```

2. **Add webhook route in `api/server.ts`**

3. **Initialize in `index.ts`**

## Trade-offs

| Benefit | Cost |
|---------|------|
| Easy to understand | Services not mockable (inject deps for testable handlers) |
| Fast navigation | Adding platforms requires some duplication |
| Minimal boilerplate | May need refactoring at scale |
