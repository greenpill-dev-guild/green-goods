---
description: State management patterns — TanStack Query, Zustand, React Hook Form, provider hierarchy
globs:
  - providers/**
  - hooks/**
  - state/**
alwaysApply: false
---

# State Management Patterns

Green Goods client uses specialized tools for different state concerns: TanStack Query for server state, Zustand for UI state, React Hook Form for forms, and React Context for cross-cutting concerns.

## State Categories

### 1. Server State → TanStack Query

**Use for:** Data from blockchain, GraphQL APIs, IPFS

**Examples:**
- Gardens list
- Work submissions
- Actions
- Gardeners
- EAS attestations

### 2. UI State → Zustand

**Use for:** Ephemeral UI state, modals, selections

**Examples:**
- Work dashboard open/closed
- Selected garden/action during submission
- Current workflow tab

### 3. Form State → React Hook Form

**Use for:** Form inputs, validation, submission

**Examples:**
- Work submission form
- Garden creation form
- Profile edit form

### 4. Global Context → React Context

**Use for:** Auth, app config, feature flags

**Examples:**
- Authentication state
- App settings (language, theme)
- Job queue provider

## Provider Hierarchy

Required nesting order:

```tsx
// main.tsx / App.tsx
<WagmiProvider>           {/* 1. Wallet infrastructure */}
  <AppProvider>           {/* 2. App settings (language, PWA state) */}
    <AuthProvider>        {/* 3. Authentication (passkey or wallet) */}
      <QueryClientProvider> {/* 4. TanStack Query */}
        <JobQueueProvider>   {/* 5. Offline job processing */}
          <WorkProvider>     {/* 6. Work submission state */}
            <AppRoutes />
          </WorkProvider>
        </JobQueueProvider>
      </QueryClientProvider>
    </AuthProvider>
  </AppProvider>
</WagmiProvider>
```

**Why this order:**
- WagmiProvider must wrap AuthProvider (wallet access)
- AuthProvider must wrap QueryClientProvider (user in cache keys)
- JobQueueProvider needs QueryClient for invalidations
- WorkProvider needs JobQueue for submissions

## TanStack Query Patterns

### Query Configuration

```typescript
// modules/react-query.ts
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: 'offlineFirst',  // Work offline
      staleTime: 5 * 60 * 1000,     // 5 minutes
      gcTime: 30 * 60 * 1000,       // 30 minutes
      retry: 1,
      refetchOnReconnect: true,
    },
    mutations: {
      networkMode: 'offlineFirst',
      retry: 1,
    },
  },
});
```

### Centralized Query Keys

**MANDATORY:** Use queryKeys factory from `hooks/query-keys.ts`:

```typescript
// hooks/query-keys.ts
export const queryKeys = {
  works: {
    all: ['jobQueue', 'works'] as const,
    online: (gardenId: string, chainId: number) =>
      ['jobQueue', 'works', 'online', gardenId, chainId] as const,
    offline: (gardenId: string) =>
      ['jobQueue', 'works', 'offline', gardenId] as const,
    merged: (gardenId: string, chainId: number) =>
      ['jobQueue', 'works', 'merged', gardenId, chainId] as const,
  },
  queue: {
    stats: () => ['jobQueue', 'queue', 'stats'] as const,
    pendingCount: () => ['jobQueue', 'queue', 'pendingCount'] as const,
  },
  // ... more keys
};
```

**Usage:**
```typescript
// Correct
const { data: works } = useQuery({
  queryKey: queryKeys.works.merged(gardenId, chainId),
  queryFn: () => getMergedWorks(gardenId, chainId)
});

// Wrong - ad-hoc keys
const { data: works } = useQuery({
  queryKey: ['works', gardenId],  // ❌ Don't construct manually
  queryFn: () => getWorks(gardenId)
});
```

### Query Invalidation

```typescript
import { queryInvalidation } from '@/hooks/query-keys';

// Invalidate all works for a garden
queryClient.invalidateQueries({ queryKey: queryKeys.works.all });

// Invalidate specific garden works
const keysToInvalidate = queryInvalidation.invalidateWorksForGarden(gardenId, chainId);
keysToInvalidate.forEach(key => {
  queryClient.invalidateQueries({ queryKey: key });
});

// Invalidate on job completion
const keysToInvalidate = queryInvalidation.onJobCompleted(gardenId, chainId);
```

### Prefetching Pattern

```typescript
// App.tsx - prefetch base lists at startup
useEffect(() => {
  void ensureBaseLists();
}, []);

// hooks/blockchain/prefetch.ts
export function ensureBaseLists(chainId = DEFAULT_CHAIN_ID) {
  const actionsPromise = queryClient.ensureQueryData({
    queryKey: ['actions', chainId],
    queryFn: () => getActions(),
  });
  const gardensPromise = queryClient.ensureQueryData({
    queryKey: ['gardens', chainId],
    queryFn: () => getGardens(),
  });
  
  return { actionsPromise, gardensPromise };
}
```

## Zustand Patterns

### Store Definition

```typescript
// state/useWorkFlowStore.ts
import { create } from 'zustand';

export const useWorkFlowStore = create<WorkFlowState>((set) => ({
  // State
  gardenAddress: null,
  actionUID: null,
  images: [],
  activeTab: WorkTab.Intro,
  
  // Actions
  setGardenAddress: (id) => set({ gardenAddress: id }),
  setActionUID: (uid) => set({ actionUID: uid }),
  setImages: (files) => set({ images: files }),
  setActiveTab: (tab) => set({ activeTab: tab }),
  
  // Reset
  reset: () => set({
    gardenAddress: null,
    actionUID: null,
    images: [],
    activeTab: WorkTab.Intro
  }),
}));
```

### Usage in Components

```typescript
function GardenView() {
  // Select specific slices
  const gardenAddress = useWorkFlowStore(s => s.gardenAddress);
  const setGardenAddress = useWorkFlowStore(s => s.setGardenAddress);
  
  // Or destructure (less optimal, more re-renders)
  const { images, setImages } = useWorkFlowStore();
}
```

### When to Use Zustand

**✅ Use Zustand for:**
- Ephemeral UI state (modal open/closed)
- Workflow state (multi-step forms)
- Selected items (current garden, action)
- UI preferences (theme, sidebar open)

**❌ Don't Use Zustand for:**
- Server data (use TanStack Query)
- Form state (use React Hook Form)
- Auth state (use AuthProvider context)

## React Context Patterns

### Provider Structure

```typescript
// providers/work.tsx
interface WorkDataProps {
  gardens: Garden[];
  actions: Action[];
  isLoading: boolean;
  workMutation: UseMutationResult<...>;
  form: {
    register: UseFormRegister<WorkDraft>;
    control: Control<WorkDraft>;
    uploadWork: (e?: React.BaseSyntheticEvent) => Promise<void>;
    // ... form methods
  };
  activeTab: WorkTab;
  setActiveTab: Dispatch<SetStateAction<WorkTab>>;
}

const WorkContext = createContext<WorkDataProps>(/* defaults */);

export const useWork = () => useContext(WorkContext);

export const WorkProvider = ({ children }) => {
  // Fetch base data
  const { data: actionsData = [] } = useActions(chainId);
  const { data: gardensData = [] } = useGardens(chainId);
  
  // Local state (Zustand)
  const actionUID = useWorkFlowStore(s => s.actionUID);
  const gardenAddress = useWorkFlowStore(s => s.gardenAddress);
  
  // Form state (React Hook Form)
  const { control, register, handleSubmit } = useForm<WorkDraft>({
    resolver: zodResolver(workSchema),
  });
  
  // Mutation (TanStack Query)
  const workMutation = useMutation({
    mutationFn: submitWork,
    onSuccess: () => { /* ... */ }
  });
  
  return (
    <WorkContext.Provider value={{
      gardens: gardensData,
      actions: actionsData,
      workMutation,
      form: { register, control, /* ... */ },
      /* ... */
    }}>
      {children}
    </WorkContext.Provider>
  );
};
```

### Context vs Zustand Decision

**Use Context when:**
- Providing dependencies (auth, config)
- Wrapping complex logic (WorkProvider)
- Need React lifecycle integration

**Use Zustand when:**
- Simple state updates
- No lifecycle needs
- Want selector optimizations
- Prefer single source of truth

## React Hook Form Integration

### Form Setup

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const workSchema = z.object({
  feedback: z.string().min(1, 'Feedback is required'),
  plantSelection: z.array(z.string()).default([]),
  plantCount: z.number().nonnegative().optional(),
});

type WorkDraft = z.infer<typeof workSchema>;

const { control, register, handleSubmit, formState, watch } = useForm<WorkDraft>({
  defaultValues: {
    feedback: '',
    plantSelection: [],
  },
  mode: 'onChange',
  resolver: zodResolver(workSchema),
});
```

### Form Components

```typescript
// Using register
<FormInput
  label="Feedback"
  {...register('feedback')}
  error={formState.errors.feedback?.message}
/>

// Using Controller (for complex components)
<Controller
  name="plantSelection"
  control={control}
  render={({ field }) => (
    <Select
      value={field.value}
      onChange={field.onChange}
      options={plantOptions}
    />
  )}
/>
```

### Form Submission

```typescript
const onSubmit = handleSubmit(async (data: WorkDraft) => {
  const errors = validateWorkDraft(data, gardenAddress, actionUID, images);
  if (errors.length > 0) {
    toast.error(errors[0]);
    return;
  }
  
  await workMutation.mutateAsync({ draft: data, images });
});

// In JSX
<form onSubmit={onSubmit}>
  {/* form fields */}
  <button type="submit" disabled={!formState.isValid}>
    Submit
  </button>
</form>
```

## Provider Bridge Pattern

### Bridging Zustand to Context

When providers need to expose Zustand state with React.Dispatch API:

```typescript
// providers/work.tsx
const actionUID = useWorkFlowStore(s => s.actionUID);
const _setActionUID = useWorkFlowStore(s => s.setActionUID);

// Adapter to maintain Dispatch API
const setActionUID: Dispatch<SetStateAction<number | null>> = (updater) => {
  const next = typeof updater === 'function'
    ? updater(actionUID)
    : updater;
  _setActionUID(next);
};

// Expose via context
return (
  <WorkContext.Provider value={{ actionUID, setActionUID, /* ... */ }}>
    {children}
  </WorkContext.Provider>
);
```

**Why:** Consumers expect `useState`-like API but we use Zustand internally.

## Query + Mutation Patterns

### Standard Query Hook

```typescript
export function useActions(chainId: number = DEFAULT_CHAIN_ID) {
  return useQuery({
    queryKey: ['actions', chainId],
    queryFn: () => getActions(),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}
```

### Mutation with Events

```typescript
const workMutation = useMutation({
  mutationFn: async ({ draft, images }) => {
    const { txHash, jobId } = await submitWorkToQueue(/*...*/);
    
    // Inline process if possible
    if (smartAccountClient) {
      await processWorkJobInline(jobId, chainId, smartAccountClient);
    }
    return txHash;
  },
  
  onMutate: () => {
    toast.loading('Uploading work...', { id: 'work-upload' });
  },
  
  onSuccess: () => {
    toast.dismiss('work-upload');
    // Invalidation happens via events, not here
  },
  
  onError: (error) => {
    toast.error(formatJobError(error.message));
    toast.dismiss('work-upload');
  },
});
```

## State Synchronization

### Cross-Tab Communication

```typescript
// Event bus handles cross-tab sync
jobQueueEventBus.emit('job:added', { jobId, job });

// Other tabs listening
jobQueueEventBus.on('job:added', ({ jobId }) => {
  queryClient.invalidateQueries({ queryKey: queryKeys.queue.stats() });
});
```

### React Query Persistence

```typescript
// App.tsx - persist query cache to IndexedDB
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client';

const idbPersister = createIDBPersister({
  dbName: 'gg-react-query',
  storeName: 'rq'
});

<PersistQueryClientProvider client={queryClient} persistOptions={{ persister: idbPersister }}>
  {/* app */}
</PersistQueryClientProvider>
```

**Benefits:**
- Query cache survives page refresh
- Faster initial load
- Better offline experience

## Hook Composition Patterns

### Custom Hook with Query + Events

```typescript
export function useWorks(gardenId: string) {
  const chainId = DEFAULT_CHAIN_ID;
  const queryClient = useQueryClient();
  
  const merged = useMerged<WorkCard[], Job<WorkJobPayload>[], Work[]>({
    onlineKey: queryKeys.works.online(gardenId, chainId),
    offlineKey: queryKeys.works.offline(gardenId),
    mergedKey: queryKeys.works.merged(gardenId, chainId),
    
    fetchOnline: () => getWorks(gardenId, chainId),
    fetchOffline: async () => {
      const jobs = await jobQueue.getJobs({ kind: 'work', synced: false });
      return jobs.filter(job => job.payload.gardenAddress === gardenId);
    },
    
    merge: async (online, offline) => {
      /* merge logic */
    },
    
    // Event-driven invalidation
    events: [{
      subscribe: (listener) => jobQueueEventBus.onMultiple(
        ['job:added', 'job:completed', 'job:failed'],
        () => listener()
      )
    }]
  });
  
  // Additional invalidations
  useJobQueueEvents(['job:completed'], () => {
    queryClient.invalidateQueries({ queryKey: queryKeys.works.online(gardenId, chainId) });
  });
  
  return {
    works: merged.merged.data || [],
    isLoading: merged.merged.isLoading,
    error: merged.merged.error,
    refetch: () => merged.merged.refetch(),
  };
}
```

### useMerged Hook Pattern

Custom hook for online/offline data merging:

```typescript
export function useMerged<TOnline, TOffline, TMerged>(options: {
  onlineKey: QueryKey;
  offlineKey: QueryKey;
  mergedKey: QueryKey;
  fetchOnline: () => Promise<TOnline>;
  fetchOffline: () => Promise<TOffline>;
  merge: (online: TOnline, offline: TOffline) => Promise<TMerged> | TMerged;
  events?: Array<{ subscribe: (listener: () => void) => () => void }>;
}) {
  const onlineQuery = useQuery({
    queryKey: options.onlineKey,
    queryFn: options.fetchOnline,
    staleTime: 30_000,
  });
  
  const offlineQuery = useQuery({
    queryKey: options.offlineKey,
    queryFn: options.fetchOffline,
    staleTime: 5_000,
  });
  
  const mergedQuery = useQuery({
    queryKey: options.mergedKey,
    queryFn: () => options.merge(onlineQuery.data!, offlineQuery.data!),
    enabled: !onlineQuery.isLoading && !offlineQuery.isLoading,
  });
  
  // Event-driven invalidation
  useEffect(() => {
    const unsubs = (options.events || []).map(({ subscribe }) =>
      subscribe(() => {
        queryClient.invalidateQueries({ queryKey: options.offlineKey });
        queryClient.invalidateQueries({ queryKey: options.mergedKey });
      })
    );
    return () => unsubs.forEach(u => u());
  }, []);
  
  return { online: onlineQuery, offline: offlineQuery, merged: mergedQuery };
}
```

**Use for:** Any data that has both online and offline sources.

## Auth State Pattern

### AuthProvider Structure

```typescript
// providers/auth.tsx
export type AuthMode = 'passkey' | 'wallet' | null;

interface AuthContextType {
  authMode: AuthMode;
  
  // Passkey state
  credential: P256Credential | null;
  smartAccountAddress: Hex | null;
  smartAccountClient: SmartAccountClient | null;
  
  // Wallet state
  walletAddress: Hex | null;
  walletConnector: Connector | null;
  
  // Status
  isCreating: boolean;
  isReady: boolean;
  error: Error | null;
  
  // Actions
  createPasskey: () => Promise<void>;
  clearPasskey: () => void;
  connectWallet: (connector: Connector) => Promise<void>;
  disconnectWallet: () => void;
}
```

### Using Auth State

```typescript
import { useAuth } from '@/hooks/auth/useAuth';

function MyComponent() {
  const { smartAccountAddress, smartAccountClient, isReady } = useAuth();
  
  // Guard on ready state
  if (!isReady) return <Loader />;
  
  // Use smart account
  const handleTransaction = async () => {
    if (!smartAccountClient) return;
    
    const txHash = await smartAccountClient.sendTransaction({
      to: gardenAddress,
      data: encodedData,
      value: 0n,
    });
  };
}
```

### useUser Adapter Pattern

```typescript
// hooks/auth/useUser.ts
export function useUser(): UseUserReturn {
  const { authMode, walletAddress, smartAccountAddress, smartAccountClient, credential, isReady } = useAuth();
  
  // Backward compatibility adapter
  const primaryAddress = authMode === 'wallet' ? walletAddress : smartAccountAddress;
  const eoa = authMode === 'wallet' && walletAddress ? { address: walletAddress } : null;
  
  const user = primaryAddress ? {
    id: authMode === 'wallet' ? walletAddress! : credential?.id || primaryAddress,
    wallet: { address: primaryAddress },
  } : null;
  
  return { user, ready: isReady, eoa, smartAccountAddress, smartAccountClient };
}
```

## JobQueue Provider Pattern

### Provider Implementation

```typescript
// providers/jobQueue.tsx
export const JobQueueProvider = ({ children }) => {
  const { smartAccountClient } = useUser();
  const [stats, setStats] = useState<QueueStats>({ total: 0, pending: 0, failed: 0, synced: 0 });
  
  // Subscribe to queue events
  useEffect(() => {
    const handleQueueEvent = (event: QueueEvent) => {
      // Update stats, invalidate queries, show toasts
      switch (event.type) {
        case 'job_added':
          updateStats();
          queryClient.invalidateQueries({ queryKey: queryKeys.queue.pendingCount() });
          break;
        case 'job_completed':
          updateStats();
          if (event.job?.kind === 'work') {
            toast.success('Work uploaded');
            // Invalidate work queries
          }
          break;
      }
    };
    
    const unsubscribe = jobQueue.subscribe(handleQueueEvent);
    return unsubscribe;
  }, []);
  
  return (
    <JobQueueContext.Provider value={{ stats, /* ... */ }}>
      {children}
    </JobQueueContext.Provider>
  );
};
```

### Provider Responsibilities

JobQueueProvider handles:
1. Event subscription and cleanup
2. Toast notifications for job lifecycle
3. Query invalidation coordination
4. Stats tracking and exposure

## Form State Bridging

### Integrating React Hook Form with Context

```typescript
// providers/work.tsx
const { control, register, handleSubmit, watch } = useForm<WorkDraft>({
  defaultValues: { feedback: '', plantSelection: [] },
  resolver: zodResolver(workSchema),
});

const feedback = watch('feedback');
const plantSelection = watch('plantSelection');

// Expose form state and methods via context
return (
  <WorkContext.Provider value={{
    form: {
      control,
      register,
      uploadWork: handleSubmit(onSubmit),
      feedback,      // Watched value
      plantSelection, // Watched value
      // ...
    }
  }}>
    {children}
  </WorkContext.Provider>
);
```

**Pattern:** Context exposes form state for consumers without prop drilling.

## State Update Patterns

### Optimistic Updates

```typescript
const mutation = useMutation({
  mutationFn: async (data) => {
    // Network request
    return await api.updateGarden(data);
  },
  
  onMutate: async (newData) => {
    // Cancel ongoing queries
    await queryClient.cancelQueries({ queryKey: ['gardens', gardenId] });
    
    // Snapshot previous value
    const previous = queryClient.getQueryData(['gardens', gardenId]);
    
    // Optimistically update
    queryClient.setQueryData(['gardens', gardenId], (old) => ({
      ...old,
      ...newData
    }));
    
    return { previous };
  },
  
  onError: (err, variables, context) => {
    // Rollback on error
    queryClient.setQueryData(['gardens', gardenId], context.previous);
  },
  
  onSettled: () => {
    // Refetch to ensure consistency
    queryClient.invalidateQueries({ queryKey: ['gardens', gardenId] });
  },
});
```

### Partial Data Updates

```typescript
// Update specific work in list
queryClient.setQueriesData<Work[]>(
  { queryKey: ['works'] },
  (oldWorks = []) => {
    return oldWorks.map(work =>
      work.id === workUID
        ? { ...work, status: approved ? 'approved' : 'rejected' }
        : work
    );
  }
);
```

## Anti-Patterns

### ❌ Don't Mix State Management Tools

```typescript
// Wrong - using multiple tools for same concern
const [gardens, setGardens] = useState([]);           // ❌
const { data: gardensFromQuery } = useQuery(/*...*/); // ❌
const gardensFromZustand = useGardenStore(s => s.gardens); // ❌

// Correct - one tool per concern
const { data: gardens } = useQuery(/*...*/); // ✅ Server state
```

### ❌ Don't Create Prop Drilling

```typescript
// Wrong
<Parent garden={garden}>
  <Child garden={garden}>
    <GrandChild garden={garden}>
      <GreatGrandChild garden={garden} />

// Correct - use context or query
function GreatGrandChild() {
  const { garden } = useGarden(); // From context or query
}
```

### ❌ Don't Store Derived State

```typescript
// Wrong
const [works, setWorks] = useState([]);
const [pendingWorks, setPendingWorks] = useState([]);
useEffect(() => {
  setPendingWorks(works.filter(w => w.status === 'pending'));
}, [works]);

// Correct - compute derived state
const works = useWorks();
const pendingWorks = useMemo(
  () => works.filter(w => w.status === 'pending'),
  [works]
);
```

### ❌ Don't Bypass Query Keys

```typescript
// Wrong - inline query
const { data } = useQuery({
  queryKey: ['works', gardenId],
  queryFn: () => fetch('/api/works')
});

// Correct - use centralized keys
import { queryKeys } from '@/hooks/query-keys';
const { data } = useQuery({
  queryKey: queryKeys.works.online(gardenId, chainId),
  queryFn: () => getWorks(gardenId, chainId)
});
```

## MCP Integration

Use GitHub MCP for state management decisions:

```bash
# Document state decisions
@github: Create issue "Document why we use Zustand for workflow state vs Context"

# Track refactoring
@github: Create issue "Migrate legacy useState to Zustand in ProfileSettings" with label refactor
```

## Reference Files

- TanStack Query config: `src/modules/react-query.ts`
- Query keys: `src/hooks/query-keys.ts`
- Zustand stores: `src/state/useUIStore.ts`, `src/state/useWorkFlowStore.ts`
- Auth provider: `src/providers/auth.tsx`
- Work provider: `src/providers/work.tsx`
- JobQueue provider: `src/providers/jobQueue.tsx`
- App provider: `src/providers/app.tsx`
- useMerged hook: `src/hooks/app/useMerged.ts`
