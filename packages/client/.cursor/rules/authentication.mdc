---
description: Authentication patterns — passkey-first, WebAuthn, Pimlico, smart accounts, Wagmi fallback
globs:
  - "packages/shared/src/providers/*Auth*.tsx"
  - "packages/shared/src/hooks/auth/**"
  - "packages/shared/src/modules/auth/**"
  - "packages/client/src/routes/RequireAuth.tsx"
  - "packages/client/src/routes/RequireInstalled.tsx"
alwaysApply: false
---

# Authentication & Account Abstraction

Green Goods uses **passkey-first authentication** with WebAuthn credentials and Kernel smart accounts via Pimlico. Wallet connection provides fallback for operators and admins.

## Simplified Auth Architecture (v2)

The auth system was refactored to be minimal and avoid race conditions:

### Storage Keys (Only 2)

```typescript
// packages/shared/src/modules/auth/session.ts
export const PASSKEY_STORAGE_KEY = "greengoods_passkey_credential";  // WebAuthn credential
export const AUTH_MODE_STORAGE_KEY = "greengoods_auth_mode";         // "passkey" | "wallet"
```

### Core API (Only 3 Methods)

```typescript
const {
  loginWithPasskey,   // Create/authenticate passkey
  loginWithWallet,    // Open wallet modal  
  signOut,            // Clear all auth

  authMode,           // "passkey" | "wallet" | null
  isAuthenticated,
  isReady,
} = useClientAuth();
```

## Provider Hierarchy

```tsx
// packages/client/src/main.tsx
<AppErrorBoundary>
  <AppKitProvider>        {/* WagmiProvider */}
    <ClientAuthProvider>  {/* PasskeyAuth + wallet sync */}
      <AppProvider>       {/* QueryClient + IntlProvider */}
        <App />
      </AppProvider>
    </ClientAuthProvider>
  </AppKitProvider>
</AppErrorBoundary>
```

## Critical Implementation Rules

### 1. Use `disconnect` from `@wagmi/core`, NOT `useDisconnect` hook

```typescript
// ✅ Correct - doesn't require QueryClient
import { disconnect } from "@wagmi/core";
import { useConfig } from "wagmi";

const wagmiConfig = useConfig();
await disconnect(wagmiConfig);

// ❌ Wrong - requires QueryClientProvider ancestor
import { useDisconnect } from "wagmi";
const { disconnectAsync } = useDisconnect(); // Will throw if no QueryClient
```

**Why:** `useDisconnect` uses TanStack Query internally. `ClientAuthProvider` renders before `QueryClientProvider` in our hierarchy.

### 2. Trust PasskeyAuth for restoration, don't clear auth mode prematurely

```typescript
// ✅ Correct - set mode immediately, sync effect handles failures
useEffect(() => {
  const savedMode = getAuthMode();
  
  if (savedMode === "passkey") {
    setAuthMode("passkey");  // Trust PasskeyAuth to restore
  } else if (savedMode === "wallet") {
    setAuthMode("wallet");
  }
  // No else - don't clear if nothing saved
}, []);

// ❌ Wrong - creates race condition
if (savedMode === "passkey" && passkeyAuth.isAuthenticated) {
  // passkeyAuth.isAuthenticated may be false during async restore
}
```

### 3. Handle failed passkey restore with sync effect

```typescript
// Sync effect catches when passkey restore fails
useEffect(() => {
  if (!isReady) return;

  // Passkey was expected but failed to restore
  if (!passkeyAuth.isAuthenticated && 
      !passkeyAuth.isAuthenticating && 
      authMode === "passkey" && 
      passkeyAuth.isReady) {
    setAuthMode(null);
    clearAuthMode();
  }
}, [passkeyAuth.isAuthenticated, passkeyAuth.isAuthenticating, passkeyAuth.isReady, authMode, isReady]);
```

## Authentication Modes

```typescript
export type AuthMode = 'passkey' | 'wallet' | null;
```

### Passkey Mode (Primary)

**For:** Gardeners, general users
**Tech:** WebAuthn + viem/account-abstraction + Kernel + Pimlico
**UX:** Biometric authentication, no seed phrases, sponsored transactions

### Wallet Mode (Fallback)

**For:** Operators, admins, power users
**Tech:** Wagmi + Reown AppKit + MetaMask/WalletConnect
**UX:** Traditional wallet connection

## Login Flow Implementation

```typescript
// packages/client/src/views/Login/index.tsx
export function Login() {
  const {
    loginWithPasskey,
    loginWithWallet,
    isAuthenticating,
    isAuthenticated,
    isReady,
  } = useClientAuth();

  const handlePasskeyLogin = async () => {
    const session = await loginWithPasskey();
    // Auto-redirect handled by isAuthenticated check
  };

  const handleWalletLogin = () => {
    loginWithWallet();  // Opens AppKit modal
  };

  if (!isReady) return <LoadingScreen />;
  if (isAuthenticated) return <Navigate to="/home" />;

  return (
    <Splash
      login={handlePasskeyLogin}
      isLoggingIn={isAuthenticating}
      secondaryAction={{ label: "Login with wallet", onSelect: handleWalletLogin }}
    />
  );
}
```

## Auth Mode Branching for Transactions

```typescript
const { authMode, smartAccountClient } = useClientAuth();

if (authMode === 'wallet') {
  // Direct wallet submission
  const hash = await submitWorkDirectly(draft, gardenAddress, actionUID);
} else {
  // Passkey mode - use job queue
  const { txHash, jobId } = await submitWorkToQueue(draft, gardenAddress, actionUID);
  
  if (smartAccountClient) {
    await processWorkJobInline(jobId, chainId, smartAccountClient);
  }
}
```

## ClientAuth Provider Implementation

```typescript
// packages/shared/src/providers/ClientAuth.tsx
function ClientAuthProviderInner({ children }) {
  const wagmiConfig = useConfig();
  const passkeyAuth = usePasskeyAuth();
  const { address, isConnected } = useAccount();

  const [authMode, setAuthMode] = useState<AuthMode>(null);
  const [isReady, setIsReady] = useState(false);

  // Helper using core disconnect (NOT useDisconnect hook)
  const disconnectWallet = useCallback(async () => {
    await disconnect(wagmiConfig);
  }, [wagmiConfig]);

  // Initialize on mount - trust saved mode
  useEffect(() => {
    const savedMode = getAuthMode();
    if (savedMode === "passkey") setAuthMode("passkey");
    else if (savedMode === "wallet") setAuthMode("wallet");
    setIsReady(true);
  }, []);

  // Sync wallet disconnection
  useEffect(() => {
    if (isReady && !isConnected && authMode === "wallet") {
      setAuthMode(null);
      clearAuthMode();
    }
  }, [isConnected, authMode, isReady]);

  // Sync passkey auth changes
  useEffect(() => {
    if (isReady && passkeyAuth.isAuthenticated && authMode !== "passkey") {
      setAuthMode("passkey");
      saveAuthMode("passkey");
    }
    // Handle failed passkey restore
    if (isReady && !passkeyAuth.isAuthenticated && !passkeyAuth.isAuthenticating 
        && authMode === "passkey" && passkeyAuth.isReady) {
      setAuthMode(null);
      clearAuthMode();
    }
  }, [passkeyAuth.isAuthenticated, passkeyAuth.isAuthenticating, passkeyAuth.isReady, authMode, isReady]);

  const loginWithPasskey = useCallback(async () => {
    if (isConnected) await disconnectWallet();
    const session = await passkeyAuth.createPasskey();
    setAuthMode("passkey");
    saveAuthMode("passkey");
    return session;
  }, [passkeyAuth, isConnected, disconnectWallet]);

  const loginWithWallet = useCallback(() => {
    if (passkeyAuth.isAuthenticated) passkeyAuth.signOut();
    setAuthMode("wallet");
    saveAuthMode("wallet");
    appKit.open();
  }, [passkeyAuth]);

  const signOut = useCallback(async () => {
    passkeyAuth.signOut();
    await disconnectWallet();
    setAuthMode(null);
    clearAllAuth();
    queryClient.clear();
  }, [passkeyAuth, disconnectWallet]);

  // ...context value
}
```

## Route Guards

```typescript
// packages/client/src/routes/RequireAuth.tsx
export default function RequireAuth() {
  const { isAuthenticated, isReady } = useClientAuth();
  const location = useLocation();

  if (!isReady) return null;

  if (!isAuthenticated) {
    const redirectTo = encodeURIComponent(location.pathname + location.search);
    return <Navigate to={`/login?redirectTo=${redirectTo}`} replace />;
  }

  return <Outlet />;
}
```

## Anti-Patterns

### ❌ Don't use `useDisconnect` hook in ClientAuth

```typescript
// Wrong - useDisconnect requires QueryClientProvider
const { disconnectAsync } = useDisconnect();

// Correct - use core function with config
import { disconnect } from "@wagmi/core";
await disconnect(wagmiConfig);
```

### ❌ Don't check `passkeyAuth.isAuthenticated` on init

```typescript
// Wrong - creates race condition during async restore
if (savedMode === "passkey" && passkeyAuth.isAuthenticated) {
  setAuthMode("passkey");
} else {
  clearAuthMode();  // Clears prematurely!
}

// Correct - trust saved mode, sync effect handles failures
if (savedMode === "passkey") {
  setAuthMode("passkey");
}
```

### ❌ Don't skip isReady check

```typescript
// Wrong
const { smartAccountClient } = useClientAuth();
await smartAccountClient.sendTransaction({/*...*/});

// Correct
const { smartAccountClient, isReady } = useClientAuth();
if (!isReady || !smartAccountClient) return;
await smartAccountClient.sendTransaction({/*...*/});
```

## Testing Authentication

```typescript
// Mock auth for testing
vi.mock('@green-goods/shared/providers', () => ({
  useClientAuth: () => ({
    authMode: 'passkey',
    isAuthenticated: true,
    isReady: true,
    loginWithPasskey: vi.fn(),
    loginWithWallet: vi.fn(),
    signOut: vi.fn(),
  }),
}));
```

## Reference Files

**Providers:**
- `packages/shared/src/providers/ClientAuth.tsx` — Unified auth provider
- `packages/shared/src/providers/PasskeyAuth.tsx` — Passkey-only auth
- `packages/shared/src/providers/WalletAuth.tsx` — Wallet-only auth (admin)

**Session:**
- `packages/shared/src/modules/auth/session.ts` — Storage utilities (2 keys only)
- `packages/shared/src/modules/auth/passkey.ts` — WebAuthn credential management

**Route Guards:**
- `packages/client/src/routes/RequireAuth.tsx`
- `packages/client/src/routes/RequireInstalled.tsx`

**Login:**
- `packages/client/src/views/Login/index.tsx`
