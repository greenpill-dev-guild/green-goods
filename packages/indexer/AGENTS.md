# Green Goods Indexer — Envio GraphQL

The indexer exposes Green Goods blockchain data via GraphQL using Envio.

## Quick Reference

| Command | Description |
|---------|-------------|
| `bun dev` | Start indexer (checks Docker, stops existing, sets up ReScript, starts) |
| `bun stop` | Stop indexer and kill ports 8080/9898 |
| `bun reset` | Full reset: Docker cleanup + state removal |
| `bun codegen` | Regenerate types after schema/config changes |
| `bun run setup-generated` | Setup ReScript dependencies (run after codegen) |
| `bun run dev:manual` | Start without automatic setup (assumes already setup) |
| `bun test` | Run tests (auto-bootstraps if needed) |

**Prerequisites:** Docker Desktop must be running (`open -a Docker`)

**GraphQL Playground:** http://localhost:8080 (password: `testing`)

**If "Docker not running" error:** Run `open -a Docker`, wait 30 seconds, then `bun dev`

## Architecture

```
packages/indexer/
├── config.yaml          # Envio configuration (defines contracts + ABIs)
├── schema.graphql       # GraphQL schema (entities)
├── src/
│   └── EventHandlers.ts # Event processing logic
├── queries/
│   └── OptimizedQueries.ts # Reusable GraphQL queries
├── test/
│   └── test.ts          # Event handler tests
├── generated/           # Auto-generated by Envio (includes ABIs)
├── reset-indexer.sh     # Reset script for Docker cleanup
└── setup-and-start.sh   # Setup script (called by bun dev)
```

**Note:** Contract ABIs are defined inline in `config.yaml` and auto-generated in `generated/`. No separate `abis/` folder is needed.

## Daily Workflow

```bash
# Morning: Start Docker Desktop once
open -a Docker
# Wait 30 seconds for it to fully start

# Then any time you need the indexer:
bun dev

# Stop when done:
bun stop
# or just Ctrl+C
```

## Design Principles Applied

**DRY (Don't Repeat Yourself)**
- Composite ID pattern (`${chainId}-${identifier}`) used consistently
- Helper functions for common entity operations
- Reusable query patterns in `queries/`

**KISS (Keep It Simple, Stupid)**
- Direct entity updates — no complex ORM abstractions
- Simple event → entity mapping
- Graceful degradation with sensible defaults

**Single Responsibility (SOLID)**
- Each handler processes one event type
- Clear separation: config.yaml (what to index) vs EventHandlers.ts (how to process)
- Schema defines structure, handlers define behavior

**Idempotency**
- Handlers can be re-run safely
- Create-if-not-exists pattern for update events
- Entity state is always consistent

**Defensive Programming**
- Null checks with fallback values
- Try/catch with meaningful error logs
- Bidirectional relationship updates (both sides)

---

## Entity Conventions

### Always Include chainId

**MANDATORY:** All entities must include `chainId` field:

```graphql
type Garden @entity {
  id: ID!
  chainId: Int!           # ← Required for multi-chain
  tokenAddress: String!
  tokenID: BigInt!
  name: String!
  description: String!
  # ...
}
```

**Why:** Green Goods supports multiple chains. Without chainId, frontend can't filter data correctly.

### Composite IDs

Use `chainId-identifier` pattern to prevent collisions across chains:

```typescript
// EventHandlers.ts
const gardenId = `${chainId}-${tokenId}`;
const actionId = `${chainId}-${actionUID}`;
const gardenerId = `${chainId}-${address}`;

Garden.set({
  id: gardenId,
  chainId: chainId,
  tokenAddress: event.srcAddress,
  tokenID: event.params.tokenId,
  // ...
});
```

**Why:** Same actionUID on Base Sepolia vs Arbitrum creates separate entities.

## Event Handler Patterns

### GardenCreated Handler

```typescript
GardenToken.GardenCreated.handler(async ({ event, context }) => {
  const chainId = event.chainId;
  const tokenId = event.params.tokenId.toString();
  const gardenId = `${chainId}-${tokenId}`;
  
  // Fetch metadata from contract
  const metadata = await context.GardenToken.tokenMetadata(event.params.tokenId);
  
  // Parse metadata
  const { name, description, location, bannerImage, gardeners, operators } = parseMetadata(metadata);
  
  // Create Garden entity
  context.Garden.set({
    id: gardenId,
    chainId: chainId,
    tokenAddress: event.srcAddress,
    tokenID: event.params.tokenId,
    name: name,
    description: description,
    location: location,
    bannerImage: bannerImage,
    gardeners: gardeners || [],
    operators: operators || [],
    createdAt: event.block.timestamp,
  });
});
```

### ActionRegistered Handler

```typescript
ActionRegistry.ActionRegistered.handler(async ({ event, context }) => {
  const chainId = event.chainId;
  const actionUID = event.params.actionUID.toString();
  const actionId = `${chainId}-${actionUID}`;
  
  context.Action.set({
    id: actionId,
    chainId: chainId,
    ownerAddress: event.params.owner,
    startTime: event.params.startTime,
    endTime: event.params.endTime,
    title: event.params.title,
    instructions: event.params.instructions,
    capitals: event.params.capitals,
    media: event.params.media,
    createdAt: event.block.timestamp,
  });
});
```

### Update Handler Pattern (Create-If-Not-Exists)

For update events that may arrive before creation events:

```typescript
GardenAccount.NameUpdated.handler(async ({ event, context }) => {
  const gardenId = event.srcAddress;  // Garden TBA address
  const chainId = event.chainId;
  
  // Get existing or create minimal entity
  const existingGarden = await context.Garden.get(gardenId);
  
  context.Garden.set({
    // Preserve existing fields or use defaults
    id: gardenId,
    chainId: chainId,
    tokenAddress: existingGarden?.tokenAddress ?? "",
    tokenID: existingGarden?.tokenID ?? BigInt(0),
    // Apply update
    name: event.params.name,
    // Keep other fields
    description: existingGarden?.description ?? "",
    // ...
  });
});
```

### Bidirectional Relationships

When updating relationships, update BOTH sides:

```typescript
GardenAccount.GardenerAdded.handler(async ({ event, context }) => {
  const chainId = event.chainId;
  const gardenId = event.srcAddress;
  const gardenerAddress = event.params.gardener.toLowerCase();
  const gardenerId = `${chainId}-${gardenerAddress}`;
  
  // 1. Update Garden.gardeners
  const garden = await context.Garden.get(gardenId);
  if (garden) {
    const gardeners = garden.gardeners || [];
    if (!gardeners.includes(gardenerAddress)) {
      context.Garden.set({
        ...garden,
        gardeners: [...gardeners, gardenerAddress],
      });
    }
  }
  
  // 2. Update Gardener.gardens
  const existingGardener = await context.Gardener.get(gardenerId);
  const gardens = existingGardener?.gardens || [];
  
  context.Gardener.set({
    id: gardenerId,
    chainId: chainId,
    address: gardenerAddress,
    gardens: gardens.includes(gardenId) ? gardens : [...gardens, gardenId],
    // ...
  });
});
```

## Error Handling

### Graceful Degradation

```typescript
try {
  const metadata = await context.GardenToken.tokenMetadata(tokenId);
  const parsed = JSON.parse(metadata);
  
  context.Garden.set({
    id: gardenId,
    name: parsed.name || 'Unnamed Garden',
    description: parsed.description || '',
    // ... with fallbacks
  });
} catch (error) {
  console.error(`[GardenCreated] Failed to fetch metadata for ${gardenId}:`, error);
  
  // Create garden with minimal data
  context.Garden.set({
    id: gardenId,
    chainId: chainId,
    name: 'Garden (Loading...)',
    description: '',
    // ...
  });
}
```

## Development Workflow

### When to Run Codegen

Run codegen after:
- Changing `schema.graphql`
- Updating `config.yaml`
- Adding new contract events

```bash
bun codegen
bun run setup-generated  # Rebuild ReScript after codegen
```

### Docker Management

```bash
# Start indexer (recommended)
bun dev

# Stop indexer
bun stop

# Stop containers only
docker compose down

# Reset completely
bun reset

# View logs
docker compose logs -f envio
```

### ReScript Compilation

ReScript dependencies are automatically installed when running `bun dev`.

If you encounter ReScript errors manually run:

```bash
bun run setup-generated
```

Or manually:

```bash
cd generated
pnpm install
pnpm run build
cd ..
```

**Why this is needed:** ReScript needs dependencies installed locally in `generated/` folder. bun's workspace hoisting puts dependencies at root, but Envio uses pnpm for proper Node.js module resolution.

## Troubleshooting

### "Docker is not running" Error

```bash
open -a Docker
# Wait 30 seconds for Docker to fully start
docker ps  # Verify it's working
bun dev
```

### Docker Overlay/Mount Errors

Symptoms: `failed to mount /var/lib/docker/rootfs/stargz`, `no such file or directory`

```bash
# Quick fix
bun reset

# Or manual cleanup
docker compose down -v
docker ps -a --filter "name=generated-envio" --format "{{.ID}}" | xargs docker rm -f
docker volume ls --filter "name=generated" --format "{{.Name}}" | xargs docker volume rm
rm -rf generated/persisted_state.envio.json .envio
docker system prune -f
```

Then restart Docker Desktop and run `bun dev`.

### ReScript Module Errors

Symptom: `Cannot find module 'rescript-envsafe/src/EnvSafe.res.js'`

The `bun dev` command handles this automatically. If issues persist:

```bash
bun reset
bun run setup-generated
bun run dev:manual
```

Or manually:

```bash
cd generated
pnpm install
pnpm run build
cd ..
bun run dev:manual
```

### Port Conflicts

```bash
# Port 8080 (GraphQL Playground)
lsof -i :8080
kill -9 <PID>

# Port 9898 (HyperSync)
lsof -i :9898
kill -9 <PID>

# Or use bun stop which kills both
bun stop
```

### Database Connection Issues

1. Ensure Docker Desktop is running
2. Check container health: `docker compose ps`
3. View logs: `docker compose logs -f`
4. If unhealthy, reset: `bun reset`

### Indexer Stuck or Not Processing Events

1. Check if indexer is running: `docker compose ps`
2. View logs for errors: `docker compose logs -f envio`
3. Reset and restart: `bun reset && bun dev`

## Testing

### Test Commands

```bash
# Run tests (auto-bootstraps if generated/ doesn't exist)
bun test

# Explicit full setup + test
bun run test:full

# Setup generated files only (without running tests)
bun run test:setup
```

### Test Setup

Tests require the `generated/` folder which contains Envio's test helpers:

1. `bun run codegen` — Generates TypeScript types and test helpers from `config.yaml` and `schema.graphql`
2. `bun run setup-generated` — Installs pnpm dependencies and builds ReScript in `generated/`

The `pretest` script automatically runs setup if `generated/src` doesn't exist.

### Test Coverage

Tests cover key event handler logic:

**Capital Mapping (10 tests)**
- All 8 capital types (SOCIAL, MATERIAL, FINANCIAL, LIVING, INTELLECTUAL, EXPERIENTIAL, SPIRITUAL, CULTURAL)
- UNKNOWN fallback for invalid values
- Multiple capitals in single action

**Multi-Chain ID Collision Prevention (3 tests)**
- Same actionUID on different chains creates separate entities
- Same gardener address on different chains creates separate entities
- Chain-prefixed IDs: `${chainId}-${identifier}`

**Bidirectional Gardener ↔ Garden Updates (4 tests)**
- GardenerAdded updates both Garden.gardeners and Gardener.gardens
- GardenerRemoved updates both entities
- Existing gardener added to second garden preserves firstGarden

**Create If Not Exists Pattern (4 tests)**
- NameUpdated creates minimal garden if not exists
- DescriptionUpdated, LocationUpdated, BannerImageUpdated same pattern

**Action/Garden CRUD (8+ tests)**
- ActionRegistered creates action with all fields
- Update handlers preserve other fields
- Operator add/remove
- OpenJoining toggle
- GAP project integration

### Writing New Tests

```typescript
import { TestHelpers, ActionRegistry, GardenToken, GardenAccount } from "generated";
const { MockDb, Addresses } = TestHelpers;

it("example test", async () => {
  // 1. Create mock database
  let mockDb = MockDb.createMockDb();
  
  // 2. Optionally pre-seed entities
  mockDb = mockDb.entities.Garden.set({
    id: "0x123...",
    chainId: 42161,
    // ... fields
  });
  
  // 3. Create mock event
  const mockEvent = GardenAccount.GardenerAdded.createMockEvent({
    updater: "0x...",
    gardener: "0x...",
    mockEventData: {
      chainId: 42161,
      block: { timestamp: 12345 },
      srcAddress: "0x123...", // Contract address (garden)
    },
  });
  
  // 4. Process event
  const result = await GardenAccount.GardenerAdded.processEvent({
    event: mockEvent,
    mockDb,
  });
  
  // 5. Assert results
  const garden = result.entities.Garden.get("0x123...");
  assert.ok(garden.gardeners.includes("0x..."));
});
```

## GraphQL Query Patterns

### Frontend Usage

```typescript
// Client/Admin fetches from indexer via shared package
import { greenGoodsIndexer, graphql } from '@green-goods/shared';

const QUERY = graphql(`
  query Gardens($chainId: Int!) {
    Garden(where: {chainId: {_eq: $chainId}}) {
      id
      name
      location
      gardeners
    }
  }
`);

const { data } = await greenGoodsIndexer.query(QUERY, { chainId: 84532 }).toPromise();
```

### Health Check

```bash
# Check if GraphQL is responding
curl http://localhost:8080/healthz
```

## Environment Variables

All environment variables are configured in the **root `.env` file** (at the monorepo root, not in this package).

The indexer automatically loads configuration from:
- Root `.env` file (shared across all packages)
- `config.yaml` (indexer-specific configuration)

**Client configuration:**
- Default dev endpoint: `http://localhost:8080/v1/graphql`
- Override in client via `VITE_ENVIO_INDEXER_URL`

## Reference Documentation

- Envio docs: https://docs.envio.dev
- Indexer README: `/packages/indexer/README.md`
- Root guide: `/AGENTS.md`
- Cursor rules: `.cursor/rules/development.mdc`, `.cursor/rules/envio-conventions.mdc`
