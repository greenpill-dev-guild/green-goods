enum Capital {
  SOCIAL
  MATERIAL
  FINANCIAL
  LIVING
  INTELLECTUAL
  EXPERIENTIAL
  SPIRITUAL
  CULTURAL
  UNKNOWN
}

type Action {
  id: ID!
  chainId: Int!
  ownerAddress: String! # Address
  startTime: BigInt!
  endTime: BigInt!
  title: String!
  instructions: String!
  capitals: [Capital!]!
  media: [String!]!
  createdAt: Int!
}

type Garden {
  id: ID! # Address
  chainId: Int!
  tokenAddress: String! # Address
  tokenID: BigInt!
  name: String!
  description: String!
  location: String!
  bannerImage: String!
  openJoining: Boolean!
  createdAt: Int!

  gardeners: [String!]! # Address
  operators: [String!]! # Address
  
  # Karma GAP Integration
  gapProjectUID: String # Karma GAP project attestation UID (bytes32)
}

type Gardener {
  id: ID! # Smart account address
  chainId: Int!
  createdAt: Int!
  firstGarden: String # First garden joined
  gardens: [String!]! # All gardens this gardener belongs to
  
  # Identity (from Gardener smart contract on mainnet or L2)
  owner: String # Current owner key (EOA from passkey)
  
  # ENS Identity (from mainnet Gardener contract)
  ensName: String # Full ENS name (e.g., "alice.greengoods.eth")
  passkeyCredentialId: String # WebAuthn credential ID (bytes32) for recovery
  claimedAt: Int # Timestamp of ENS claim on mainnet
  
  # Profile data stored in ENS text records (mainnet only)
  # These fields are read from ENS resolver on mainnet
  # Query via ENS resolver: resolver.text(node, "avatar"), resolver.text(node, "description"), etc.
  ensAvatar: String # ENS text record: avatar
  ensDescription: String # ENS text record: description
  ensTwitter: String # ENS text record: com.twitter
  ensGithub: String # ENS text record: com.github
  ensEmail: String # ENS text record: email
  
  # Future extensibility:
  # - totalWork: Int
  # - approvals: [WorkApproval!]
  # - reputation: Int
  # - attestations: [Attestation!]
}

# =============================================================================
# Hypercert Entities
# =============================================================================

enum HypercertStatus {
  ACTIVE
  CLAIMED
  SOLD
  UNKNOWN
}

type Hypercert {
  id: ID!                           # chainId-tokenId
  chainId: Int!
  tokenId: BigInt!
  garden: String!                   # Garden address
  metadataUri: String!              # IPFS URI (ipfs://...)
  mintedAt: Int!
  mintedBy: String!                 # Operator address who minted
  txHash: String!
  totalUnits: BigInt!
  claimedUnits: BigInt!
  attestationCount: Int!
  attestationUIDs: [String!]!       # EAS attestation UIDs bundled into this hypercert

  # Metadata fields (populated from IPFS)
  title: String
  description: String
  imageUri: String
  workScopes: [String!]

  status: HypercertStatus!
  # Note: Query claims via HypercertClaim.hypercertId (Envio doesn't support entity arrays)
  createdAt: Int!
  updatedAt: Int!
}

type HypercertClaim {
  id: ID!                           # chainId-hypercertTokenId-claimant
  chainId: Int!
  hypercertId: String!              # Reference to parent Hypercert
  claimant: String!                 # Address who claimed
  units: BigInt!
  claimedAt: Int!
  txHash: String!
}

# WorkApproval tracks which work attestations have been bundled into hypercerts
type WorkApproval {
  id: ID!                           # chainId-attestationUID
  chainId: Int!
  attestationUID: String!           # EAS attestation UID
  garden: String!                   # Garden address
  gardener: String!                 # Gardener who did the work
  approvedBy: String!               # Operator who approved
  approvedAt: Int!
  txHash: String!

  # Hypercert linkage (null until bundled)
  hypercertId: String               # Hypercert this was bundled into
  bundledAt: Int                    # Timestamp when bundled
}
