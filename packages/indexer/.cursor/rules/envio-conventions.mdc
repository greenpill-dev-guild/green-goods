---
description: Envio conventions — entity patterns, event handlers, multi-chain requirements, testing
globs:
  - schema.graphql
  - src/EventHandlers.ts
  - config.yaml
  - test/**
alwaysApply: false
---

# Envio Indexer Conventions

This rule covers Envio-specific patterns for Green Goods indexer.

## Visual Reference

See [Indexer Flow Diagram](docs/developer/architecture/diagrams.md#indexer-flow) for the complete event processing sequence from blockchain to GraphQL.

## Entity Requirements

### Mandatory: chainId Field

**All entities must include chainId:**

```graphql
type Garden @entity {
  id: ID!
  chainId: Int!  # ← REQUIRED
  # ...
}

type Action @entity {
  id: ID!
  chainId: Int!  # ← REQUIRED
  # ...
}
```

**Why:** Multi-chain support. Frontend filters by chainId.

### Composite ID Pattern

```typescript
// Format: chainId-identifier
const gardenId = `${event.chainId}-${tokenId}`;
const actionId = `${event.chainId}-${actionUID}`;
const gardenerId = `${event.chainId}-${address}`;
```

**Why:** Prevents ID collisions across chains. Same actionUID on Base Sepolia vs Arbitrum creates separate entities.

## Event Handler Pattern

```typescript
ContractName.EventName.handler(async ({ event, context }) => {
  const chainId = event.chainId;
  
  try {
    // 1. Extract event data
    const tokenId = event.params.tokenId.toString();
    
    // 2. Create composite ID
    const entityId = `${chainId}-${tokenId}`;
    
    // 3. Fetch additional data if needed
    const metadata = await context.ContractName.method(tokenId);
    
    // 4. Set entity
    context.EntityName.set({
      id: entityId,
      chainId: chainId,
      // ... fields
      createdAt: event.block.timestamp,
    });
  } catch (error) {
    console.error(`[EventName] Error processing event:`, error);
    // Graceful degradation — create with minimal data
  }
});
```

## Update Handler Pattern (Create-If-Not-Exists)

For update events that may arrive before creation events:

```typescript
GardenAccount.NameUpdated.handler(async ({ event, context }) => {
  const gardenId = event.srcAddress;  // Garden TBA address
  const chainId = event.chainId;
  
  // Get existing or create minimal entity
  const existingGarden = await context.Garden.get(gardenId);
  
  context.Garden.set({
    // Preserve existing fields or use defaults
    id: gardenId,
    chainId: chainId,
    tokenAddress: existingGarden?.tokenAddress ?? "",
    tokenID: existingGarden?.tokenID ?? BigInt(0),
    // Apply update
    name: event.params.name,
    // Keep other fields
    description: existingGarden?.description ?? "",
    // ...
  });
});
```

## Bidirectional Relationships

When updating relationships, update BOTH sides:

```typescript
GardenAccount.GardenerAdded.handler(async ({ event, context }) => {
  const chainId = event.chainId;
  const gardenId = event.srcAddress;
  const gardenerAddress = event.params.gardener.toLowerCase();
  const gardenerId = `${chainId}-${gardenerAddress}`;
  
  // 1. Update Garden.gardeners
  const garden = await context.Garden.get(gardenId);
  if (garden) {
    const gardeners = garden.gardeners || [];
    if (!gardeners.includes(gardenerAddress)) {
      context.Garden.set({
        ...garden,
        gardeners: [...gardeners, gardenerAddress],
      });
    }
  }
  
  // 2. Update Gardener.gardens
  const existingGardener = await context.Gardener.get(gardenerId);
  const gardens = existingGardener?.gardens || [];
  
  context.Gardener.set({
    id: gardenerId,
    chainId: chainId,
    address: gardenerAddress,
    gardens: gardens.includes(gardenId) ? gardens : [...gardens, gardenId],
    // ...
  });
});
```

## Testing Patterns

### Basic Test Structure

```typescript
import { TestHelpers, ActionRegistry, GardenToken, GardenAccount } from "generated";
const { MockDb, Addresses } = TestHelpers;

it("example test", async () => {
  // 1. Create mock database
  let mockDb = MockDb.createMockDb();
  
  // 2. Optionally pre-seed entities
  mockDb = mockDb.entities.Garden.set({
    id: "0x123...",
    chainId: 42161,
    // ... fields
  });
  
  // 3. Create mock event
  const mockEvent = GardenAccount.GardenerAdded.createMockEvent({
    updater: "0x...",
    gardener: "0x...",
    mockEventData: {
      chainId: 42161,
      block: { timestamp: 12345 },
      srcAddress: "0x123...", // Contract address (garden)
    },
  });
  
  // 4. Process event
  const result = await GardenAccount.GardenerAdded.processEvent({
    event: mockEvent,
    mockDb,
  });
  
  // 5. Assert results
  const garden = result.entities.Garden.get("0x123...");
  assert.ok(garden.gardeners.includes("0x..."));
});
```

### Test Categories

- **Capital Mapping:** All 8 capital types + UNKNOWN fallback
- **Multi-Chain ID Collision:** Same IDs on different chains stay separate
- **Bidirectional Updates:** Both sides of relationships update correctly
- **Create-If-Not-Exists:** Update events work without prior creation

## Reference Files

- Schema: `schema.graphql`
- Handlers: `src/EventHandlers.ts`
- Config: `config.yaml`
- Tests: `test/test.ts`
- AGENTS.md: `packages/indexer/AGENTS.md`
