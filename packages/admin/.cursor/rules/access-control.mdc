---
description: Role-based access control patterns for admin dashboard
globs:
  - "packages/shared/src/hooks/gardener/useRole.ts"
  - "packages/shared/src/hooks/garden/useGardenPermissions.ts"
  - "packages/admin/src/routes/Require*.tsx"
alwaysApply: false
---

# Access Control & Role Management

The admin dashboard uses role-based access control with three levels: admin (allowlist), operator (indexer query), and unauthorized.

**Note:** Role hooks are in `@green-goods/shared`. Route guards are in `packages/admin/src/routes/`.

## Role Hierarchy

```typescript
export type UserRole = 'deployer' | 'operator' | 'user';

// Effective permissions:
// deployer > operator > user
```

### Role Definitions

**Deployer (Admin):**
- All permissions
- Can create gardens
- Can deploy contracts
- Can manage all gardens
- Access via hardcoded allowlist

**Operator:**
- Can manage assigned gardens only
- Can add/remove gardeners in assigned gardens
- Can add/remove operators in assigned gardens
- Cannot create new gardens
- Access via indexer query

**User (Unauthorized):**
- Read-only access (if any)
- Redirected to login/unauthorized view

## useRole Hook

### Implementation

```typescript
// hooks/useRole.ts
export function useRole(): RoleInfo {
  const { address } = useAuth();
  const deploymentPermissions = useDeploymentRegistry();
  
  const { data: operatorGardens } = useQuery({
    queryKey: ['operatorGardens', address],
    queryFn: async () => {
      if (!address) return [];
      
      // Query indexer for gardens where user is operator
      const QUERY = graphql(`
        query OperatorGardens($address: String!) {
          Garden(where: {operators: {_contains: [$address]}}) {
            id
            name
          }
        }
      `);
      
      const { data } = await client.query(QUERY, { address }).toPromise();
      return data?.Garden || [];
    },
    enabled: !!address,
  });
  
  // Determine role
  const role: UserRole = deploymentPermissions.canDeploy
    ? 'deployer'
    : (operatorGardens?.length ?? 0) > 0
    ? 'operator'
    : 'user';
  
  return {
    role,
    isDeployer: role === 'deployer',
    isOperator: role === 'operator' || role === 'deployer',
    operatorGardens: operatorGardens || [],
    loading: deploymentPermissions.loading,
    deploymentPermissions,
  };
}
```

### Usage in Components

```typescript
function Dashboard() {
  const { role, isDeployer, operatorGardens, loading } = useRole();
  
  if (loading) return <Loader />;
  
  if (role === 'user') {
    return <Navigate to="/unauthorized" />;
  }
  
  return (
    <div>
      {isDeployer && <CreateGardenButton />}
      <GardensList gardens={isDeployer ? allGardens : operatorGardens} />
    </div>
  );
}
```

## Admin Allowlist

### Configuration

```typescript
// src/config.ts
export const ADMIN_ADDRESSES = [
  '0x2aa64E6d80390F5C017F0313cB908051BE2FD35e',
  '0x04D60647836bcA09c37B379550038BdaaFD82503',
];

export function isAdmin(address?: string): boolean {
  if (!address) return false;
  return ADMIN_ADDRESSES.some(
    admin => admin.toLowerCase() === address.toLowerCase()
  );
}
```

### Deployment Registry Check

```typescript
// hooks/useDeploymentRegistry.ts
export function useDeploymentRegistry() {
  const { address } = useAuth();
  const networkConfig = getNetworkContracts(chainId);
  
  const { data: isOwner } = useReadContract({
    address: networkConfig.deploymentRegistry,
    abi: DeploymentRegistryABI,
    functionName: 'owner',
    query: {
      select: (owner) => owner?.toLowerCase() === address?.toLowerCase(),
    },
  });
  
  const { data: isInAllowlist } = useReadContract({
    address: networkConfig.deploymentRegistry,
    abi: DeploymentRegistryABI,
    functionName: 'allowlist',
    args: [address],
  });
  
  return {
    isOwner: isOwner ?? false,
    isInAllowlist: isInAllowlist ?? false,
    canDeploy: isOwner || isInAllowlist,
  };
}
```

## Garden Permissions

### useGardenPermissions Hook

```typescript
// hooks/useGardenPermissions.ts
export function useGardenPermissions(): GardenPermissions {
  const { address } = useAuth();
  
  const isOperatorOfGarden = (garden: Garden): boolean => {
    if (!address) return false;
    return garden.operators.some(
      op => op.toLowerCase() === address.toLowerCase()
    );
  };
  
  const canManageGarden = (garden: Garden): boolean => {
    return isAdmin(address) || isOperatorOfGarden(garden);
  };
  
  const canAddMembers = (garden: Garden): boolean => {
    return canManageGarden(garden);
  };
  
  const canRemoveMembers = (garden: Garden): boolean => {
    return canManageGarden(garden);
  };
  
  return {
    canManageGarden,
    isOperatorOfGarden,
    canAddMembers,
    canRemoveMembers,
  };
}
```

### Usage

```typescript
function GardenDetail({ garden }: { garden: Garden }) {
  const permissions = useGardenPermissions();
  
  const canEdit = permissions.canManageGarden(garden);
  const canAddMembers = permissions.canAddMembers(garden);
  
  return (
    <div>
      {canEdit && <EditGardenButton />}
      {canAddMembers && <AddMemberButton />}
    </div>
  );
}
```

## Route Guards

### RequireAuth

```typescript
// components/RequireAuth.tsx
export function RequireAuth() {
  const { address } = useAuth();
  
  if (!address) {
    return <Navigate to="/login" replace />;
  }
  
  return <Outlet />;
}
```

### RequireRole

```typescript
// components/RequireRole.tsx
export function RequireRole({ allowedRoles }: { allowedRoles: UserRole[] }) {
  const { role, loading } = useRole();
  
  if (loading) {
    return <Loader />;
  }
  
  if (!allowedRoles.includes(role)) {
    return (
      <div className="p-8 text-center">
        <h2>Unauthorized</h2>
        <p>You don't have permission to access this page.</p>
      </div>
    );
  }
  
  return <Outlet />;
}
```

### Route Configuration

```tsx
// App.tsx
<Route element={<RequireAuth />}>
  <Route element={<DashboardLayout />}>
    {/* Admin-only routes */}
    <Route element={<RequireRole allowedRoles={['deployer']} />}>
      <Route path="/deployment" element={<Deployment />} />
      <Route path="/contracts" element={<Contracts />} />
    </Route>
    
    {/* Admin + Operator routes */}
    <Route element={<RequireRole allowedRoles={['deployer', 'operator']} />}>
      <Route path="/gardens" element={<Gardens />} />
      <Route path="/gardens/:id" element={<GardenDetail />} />
    </Route>
  </Route>
</Route>
```

## Access Control in Components

### Conditional Rendering

```typescript
function GardensList() {
  const { isDeployer, operatorGardens } = useRole();
  const { data: allGardens } = useQuery({
    queryKey: ['gardens'],
    queryFn: getGardens,
    enabled: isDeployer,  // Only fetch all if admin
  });
  
  const gardensToShow = isDeployer ? allGardens : operatorGardens;
  
  return (
    <div>
      {isDeployer && <CreateGardenButton />}
      {gardensToShow?.map(garden => <GardenCard key={garden.id} garden={garden} />)}
    </div>
  );
}
```

### Action Disabling

```typescript
function GardenActions({ garden }: { garden: Garden }) {
  const permissions = useGardenPermissions();
  const canManage = permissions.canManageGarden(garden);
  
  return (
    <div>
      <Button
        onClick={handleAddGardener}
        disabled={!canManage}
        label="Add Gardener"
      />
      <Button
        onClick={handleRemoveOperator}
        disabled={!canManage}
        label="Remove Operator"
      />
    </div>
  );
}
```

## Testing Access Control

### Test Pattern

```typescript
// __tests__/hooks/useRole.test.ts
describe('useRole', () => {
  it('returns deployer role for allowlist address', async () => {
    const { result } = renderHook(() => useRole(), {
      wrapper: ({ children }) => (
        <AuthProvider initialAddress={ADMIN_ADDRESSES[0]}>
          {children}
        </AuthProvider>
      ),
    });
    
    await waitFor(() => {
      expect(result.current.role).toBe('deployer');
      expect(result.current.isDeployer).toBe(true);
    });
  });
  
  it('returns operator role for garden operator', async () => {
    // Mock indexer to return operator gardens
    // ...
    
    expect(result.current.role).toBe('operator');
    expect(result.current.operatorGardens).toHaveLength(2);
  });
});
```

### Testing Route Guards

```typescript
// __tests__/components/RequireRole.test.tsx
it('blocks unauthorized users', () => {
  const { container } = render(
    <BrowserRouter>
      <Routes>
        <Route element={<RequireRole allowedRoles={['deployer']} />}>
          <Route path="*" element={<div>Protected</div>} />
        </Route>
      </Routes>
    </BrowserRouter>,
    {
      wrapper: ({ children }) => (
        <AuthProvider role="operator">
          {children}
        </AuthProvider>
      ),
    }
  );
  
  expect(screen.getByText(/Unauthorized/i)).toBeInTheDocument();
  expect(screen.queryByText('Protected')).not.toBeInTheDocument();
});
```

## Anti-Patterns

### ❌ Don't Hardcode Permissions

```typescript
// Wrong
if (address === '0x123...') {
  return <AdminPanel />;
}

// Correct
const { isDeployer } = useRole();
if (isDeployer) {
  return <AdminPanel />;
}
```

### ❌ Don't Skip Permission Checks

```typescript
// Wrong - assuming user has permission
async function removeOperator(gardenId, address) {
  await contract.removeOperator(address);
}

// Correct - check first
async function removeOperator(garden, address) {
  const permissions = useGardenPermissions();
  if (!permissions.canRemoveMembers(garden)) {
    throw new Error('Unauthorized');
  }
  await contract.removeOperator(address);
}
```

### ❌ Don't Expose Sensitive Data

```typescript
// Wrong - showing all gardens to operators
<GardensList gardens={allGardens} />

// Correct - filter by permission
const { isDeployer, operatorGardens } = useRole();
<GardensList gardens={isDeployer ? allGardens : operatorGardens} />
```

## Reference Files

**Hooks (in `@green-goods/shared`):**
- `packages/shared/src/hooks/gardener/useRole.ts`
- `packages/shared/src/hooks/garden/useGardenPermissions.ts`
- `packages/shared/src/hooks/blockchain/useDeploymentRegistry.ts`

**Route Guards (in admin):**
- `packages/admin/src/routes/RequireAuth.tsx`
- `packages/admin/src/routes/RequireRole.tsx`
- `packages/admin/src/routes/RequireDeployer.tsx`
- `packages/admin/src/routes/RequireOperatorOrDeployer.tsx`

**Config:**
- `packages/admin/src/config.ts` — Admin allowlist, chain config
