#!/usr/bin/env node

require("dotenv").config();
const { ethers } = require("ethers");
const fs = require("node:fs");
const path = require("node:path");
const { execSync } = require("node:child_process");
const {
  setupProvider,
  executeWithRetry,
  estimateTransactionCost,
  exportToJSON,
  formatAddress,
  ProgressBar,
} = require("./utils/garden-utils");
const { DeploymentAddresses } = require("./utils/deployment-addresses");

class BulkGardenCreator {
  constructor(options = {}) {
    this.options = {
      dryRun: false,
      network: "localhost",
      estimateGas: true,
      continueOnError: true,
      exportResults: false,
      batchSize: 1, // Process gardens one at a time by default
      delayBetweenBatches: 2000, // 2 seconds between gardens
      ...options,
    };
    this.deploymentAddresses = new DeploymentAddresses();
  }

  async loadGardensConfig(configPath) {
    if (!fs.existsSync(configPath)) {
      throw new Error(`Configuration file not found: ${configPath}`);
    }

    const configContent = fs.readFileSync(configPath, "utf8");
    const config = JSON.parse(configContent);

    // Validate config structure
    if (!config.gardens || !Array.isArray(config.gardens)) {
      throw new Error("Invalid config: 'gardens' array required");
    }

    if (config.gardens.length === 0) {
      throw new Error("No gardens specified in configuration");
    }

    // Validate each garden configuration
    for (const [index, garden] of config.gardens.entries()) {
      this.validateGardenConfig(garden, index);
    }

    return config;
  }

  validateGardenConfig(garden, index) {
    const required = ["name", "description", "location", "gardeners", "operators"];
    const missing = required.filter((field) => !garden[field]);

    if (missing.length > 0) {
      throw new Error(`Garden ${index}: Missing required fields: ${missing.join(", ")}`);
    }

    // Validate addresses
    const addressRegex = /^0x[a-fA-F0-9]{40}$/;

    if (!Array.isArray(garden.gardeners) || garden.gardeners.length === 0) {
      throw new Error(`Garden ${index}: Gardeners must be a non-empty array`);
    }

    if (!Array.isArray(garden.operators) || garden.operators.length === 0) {
      throw new Error(`Garden ${index}: Operators must be a non-empty array`);
    }

    const invalidGardeners = garden.gardeners.filter((addr) => !addressRegex.test(addr));
    const invalidOperators = garden.operators.filter((addr) => !addressRegex.test(addr));

    if (invalidGardeners.length > 0) {
      throw new Error(`Garden ${index}: Invalid gardener addresses: ${invalidGardeners.join(", ")}`);
    }

    if (invalidOperators.length > 0) {
      throw new Error(`Garden ${index}: Invalid operator addresses: ${invalidOperators.join(", ")}`);
    }

    // Validate banner image (optional)
    if (garden.bannerImage && !garden.bannerImage.startsWith("Qm") && !garden.bannerImage.startsWith("http")) {
      throw new Error(`Garden ${index}: Banner image must be IPFS hash (Qm...) or URL`);
    }
  }

  async createGarden(gardenConfig, index, totalGardens) {
    console.log(`\nğŸŒ± Creating Garden ${index + 1}/${totalGardens}: ${gardenConfig.name}`);
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");

    try {
      // Load contract addresses for the network
      const contractAddresses = this.deploymentAddresses.loadForChain(this.options.network);
      const communityToken = this.deploymentAddresses.getCommunityToken(this.options.network);

      // Set environment variables for the Forge script
      const env = {
        ...process.env,
        GARDEN_NAME: gardenConfig.name,
        GARDEN_DESCRIPTION: gardenConfig.description,
        GARDEN_LOCATION: gardenConfig.location,
        GARDEN_BANNER: gardenConfig.bannerImage || "QmVvKqpnfJm8UwRq9SF15V2jgJ86yCBsmMBmpEaoQU92bD", // Default image
        GARDENERS: JSON.stringify(gardenConfig.gardeners),
        OPERATORS: JSON.stringify(gardenConfig.operators),
        GARDEN_TOKEN: contractAddresses.gardenToken,
        COMMUNITY_TOKEN: communityToken,
      };

      if (this.options.dryRun) {
        console.log("  [DRY RUN] Would create garden:");
        console.log(`    Name: ${gardenConfig.name}`);
        console.log(`    Location: ${gardenConfig.location}`);
        console.log(`    Gardeners: ${gardenConfig.gardeners.length}`);
        console.log(`    Operators: ${gardenConfig.operators.length}`);
        return {
          success: true,
          dryRun: true,
          name: gardenConfig.name,
          location: gardenConfig.location,
          gardeners: gardenConfig.gardeners.length,
          operators: gardenConfig.operators.length,
        };
      }

      // Execute Foundry script
      const args = [
        "script",
        "script/DeployGarden.s.sol:DeployGarden",
        "--private-key",
        process.env.PRIVATE_KEY,
        "--broadcast",
      ];

      if (this.options.network !== "localhost") {
        const networkConfig = this.deploymentAddresses.getNetworkConfig(this.options.network);
        args.push("--rpc-url", networkConfig.rpcUrl);
        args.push("--chain-id", networkConfig.chainId.toString());
      } else {
        args.push("--rpc-url", "http://localhost:8545");
      }

      console.log("  ğŸ“ Executing deployment...");
      const displayArgs = args.map((arg, idx) => (idx > 0 && args[idx - 1] === "--private-key" ? "[REDACTED]" : arg));
      console.log("  forge", displayArgs.join(" "));

      const result = execSync(`forge ${args.join(" ")}`, {
        stdio: "pipe",
        env,
        cwd: path.join(__dirname, ".."),
        encoding: "utf8",
      });

      // Extract garden account address from output
      const gardenAccountMatch = result.match(/Garden minted at: (0x[a-fA-F0-9]{40})/);
      const gardenAccount = gardenAccountMatch ? gardenAccountMatch[1] : "unknown";

      console.log(`  âœ… Garden created successfully at: ${formatAddress(gardenAccount)}`);

      return {
        success: true,
        gardenAccount,
        name: gardenConfig.name,
        location: gardenConfig.location,
        gardeners: gardenConfig.gardeners.length,
        operators: gardenConfig.operators.length,
      };
    } catch (error) {
      console.error(`  âŒ Failed to create garden: ${error.message}`);

      if (!this.options.continueOnError) {
        throw error;
      }

      return {
        success: false,
        error: error.message,
        name: gardenConfig.name,
        location: gardenConfig.location,
      };
    }
  }

  async createGardens(config) {
    console.log("\nğŸ¡ Bulk Garden Creation");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log(`Network: ${this.options.network}`);
    console.log(`Total gardens: ${config.gardens.length}`);
    console.log(`Batch size: ${this.options.batchSize}`);
    console.log(`Continue on error: ${this.options.continueOnError}`);

    const { signer } = await setupProvider(this.options.network);
    console.log(`ğŸ‘¤ Deployer address: ${signer.address}`);

    // Validate environment
    if (!process.env.PRIVATE_KEY) {
      throw new Error("PRIVATE_KEY environment variable is required");
    }

    const results = {
      successful: [],
      failed: [],
      summary: {
        total: config.gardens.length,
        successful: 0,
        failed: 0,
        network: this.options.network,
        timestamp: new Date().toISOString(),
      },
    };

    const progress = new ProgressBar(config.gardens.length, "Creating gardens");

    // Process gardens in batches
    for (let i = 0; i < config.gardens.length; i += this.options.batchSize) {
      const batch = config.gardens.slice(i, i + this.options.batchSize);

      console.log(
        `\nğŸ“¦ Processing batch ${Math.floor(i / this.options.batchSize) + 1}/${Math.ceil(config.gardens.length / this.options.batchSize)}`,
      );

      for (const [batchIndex, garden] of batch.entries()) {
        const globalIndex = i + batchIndex;
        const result = await this.createGarden(garden, globalIndex, config.gardens.length);

        if (result.success) {
          results.successful.push(result);
          results.summary.successful++;
        } else {
          results.failed.push(result);
          results.summary.failed++;
        }

        progress.increment();

        // Add delay between gardens if not the last one
        if (globalIndex < config.gardens.length - 1 && this.options.delayBetweenBatches > 0) {
          console.log(`  â³ Waiting ${this.options.delayBetweenBatches / 1000}s before next garden...`);
          await new Promise((resolve) => setTimeout(resolve, this.options.delayBetweenBatches));
        }
      }
    }

    // Summary
    console.log("\n\nğŸ“Š Summary");
    console.log("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    console.log(`âœ… Successfully created: ${results.summary.successful}`);
    console.log(`âŒ Failed: ${results.summary.failed}`);
    console.log(`ğŸ“Š Success rate: ${((results.summary.successful / results.summary.total) * 100).toFixed(1)}%`);

    if (results.successful.length > 0) {
      console.log("\nCreated Gardens:");
      results.successful.forEach((garden, index) => {
        console.log(`  ${index + 1}. ${garden.name} (${garden.location})`);
        if (garden.dryRun) {
          console.log("     [DRY RUN] Would create garden");
        } else {
          console.log(`     Address: ${formatAddress(garden.gardenAccount)}`);
        }
        console.log(`     Members: ${garden.gardeners} gardeners, ${garden.operators} operators`);
      });
    }

    if (results.failed.length > 0) {
      console.log("\nFailed Gardens:");
      results.failed.forEach((garden, index) => {
        console.log(`  ${index + 1}. ${garden.name} (${garden.location})`);
        console.log(`     Error: ${garden.error}`);
      });
    }

    // Export results if requested
    if (this.options.exportResults && !this.options.dryRun) {
      const filename = `bulk-garden-creation-${Date.now()}.json`;
      exportToJSON(results, filename);
      console.log(`\nğŸ’¾ Results exported to: ${filename}`);
    }

    return results;
  }
}

// CLI
async function main() {
  const args = process.argv.slice(2);

  if (args.includes("--help") || args.includes("-h")) {
    console.log(`
ğŸ¡ Bulk Garden Creation Tool

Usage: node bulk-garden-creator.js --chain <network> --config <file> [options]

Required:
  --chain <network>      Network to use
  --config <file>        JSON configuration file

Options:
  --batch-size <n>       Number of gardens to process simultaneously (default: 1)
  --delay <ms>           Delay between gardens in milliseconds (default: 2000)
  --estimate-gas         Show gas estimates (default: true)
  --continue-on-error    Continue if garden creation fails (default: true)
  --export-results       Export results to JSON file
  --dry-run             Validate configuration without deploying

Configuration File Format:
{
  "gardens": [
    {
      "name": "Community Garden",
      "description": "A sustainable community garden",
      "location": "123 Main St, City, State",
      "bannerImage": "QmHash123...", // Optional: IPFS hash or URL
      "gardeners": ["0x123...", "0x456..."],
      "operators": ["0x789...", "0xabc..."]
    }
  ]
}

Examples:
  # Create gardens from config file
  node bulk-garden-creator.js --chain arbitrum --config gardens.json

  # Process 3 gardens simultaneously with 5s delay
  node bulk-garden-creator.js --chain arbitrum --config gardens.json --batch-size 3 --delay 5000

  # Dry run to validate config
  node bulk-garden-creator.js --chain arbitrum --config gardens.json --dry-run

Required Environment Variables:
  PRIVATE_KEY           - Private key for deployment
  [NETWORK]_RPC_URL    - RPC URL for the target network (optional, uses defaults)
    `);
    process.exit(0);
  }

  const options = {
    network: "localhost",
    dryRun: false,
    estimateGas: true,
    continueOnError: true,
    exportResults: false,
    batchSize: 1,
    delayBetweenBatches: 2000,
  };

  let configPath;

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "--chain" || arg === "--network") {
      options.network = args[++i];
    } else if (arg === "--config") {
      configPath = args[++i];
    } else if (arg === "--batch-size") {
      options.batchSize = Number.parseInt(args[++i]);
    } else if (arg === "--delay") {
      options.delayBetweenBatches = Number.parseInt(args[++i]);
    } else if (arg === "--estimate-gas") {
      options.estimateGas = args[++i] === "true";
    } else if (arg === "--continue-on-error") {
      options.continueOnError = args[++i] === "true";
    } else if (arg === "--export-results") {
      options.exportResults = true;
    } else if (arg === "--dry-run") {
      options.dryRun = true;
    }
  }

  if (!configPath) {
    console.error("âŒ --config file required");
    process.exit(1);
  }

  if (options.batchSize < 1) {
    console.error("âŒ Batch size must be at least 1");
    process.exit(1);
  }

  try {
    const creator = new BulkGardenCreator(options);
    const config = await creator.loadGardensConfig(configPath);
    await creator.createGardens(config);
  } catch (error) {
    console.error("âŒ Error:", error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { BulkGardenCreator };
