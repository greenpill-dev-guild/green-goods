// SPDX-License-Identifier: MIT
pragma solidity >=0.8.25;

import { Test } from "forge-std/Test.sol";
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import { ActionRegistry, Capital } from "../src/registries/Action.sol";
import { GardenToken } from "../src/tokens/Garden.sol";
import { GardenAccount } from "../src/accounts/Garden.sol";
import { WorkResolver } from "../src/resolvers/Work.sol";
import { AssessmentResolver } from "../src/resolvers/Assessment.sol";
import { DeploymentRegistry } from "../src/DeploymentRegistry.sol";
import { MockEAS } from "../src/mocks/EAS.sol";
import { MockERC20 } from "../src/mocks/ERC20.sol";
import { ERC6551Helper } from "./helpers/ERC6551Helper.sol";

/// @title UpgradeSafetyTest
/// @notice Tests for UUPS upgrade patterns and storage preservation
/// @dev Verifies upgrade safety, access control, and storage gap functionality
contract UpgradeSafetyTest is Test, ERC6551Helper {
    // Test contracts
    ActionRegistry private actionRegistry;
    GardenToken private gardenToken;
    WorkResolver private workResolver;
    AssessmentResolver private assessmentResolver;
    DeploymentRegistry private deploymentRegistry;

    // Mock dependencies
    MockEAS private mockEAS;
    MockERC20 private communityToken;
    GardenAccount private gardenAccountImpl;

    // Test addresses
    address private multisig = address(0x123);
    address private unauthorized = address(0x999);

    // Proxy addresses
    address private actionRegistryProxy;
    address private gardenTokenProxy;
    address private workResolverProxy;
    address private deploymentRegistryProxy;

    function setUp() public {
        // Deploy ERC6551 Registry at canonical Tokenbound address
        _deployERC6551Registry();

        // Deploy mocks
        mockEAS = new MockEAS();
        communityToken = new MockERC20();

        gardenAccountImpl = new GardenAccount(
            address(0x1001), // erc4337EntryPoint
            address(0x1002), // multicallForwarder
            address(0x1003), // erc6551Registry - will be overridden by TOKENBOUND_REGISTRY in actual use
            address(0x1004), // guardian
            address(0x2001), // workApprovalResolver
            address(0x2002) // assessmentResolver
        );

        // Deploy ActionRegistry with proxy
        ActionRegistry actionRegistryImpl = new ActionRegistry();
        bytes memory actionInitData = abi.encodeWithSelector(ActionRegistry.initialize.selector, multisig);
        ERC1967Proxy actionProxy = new ERC1967Proxy(address(actionRegistryImpl), actionInitData);
        actionRegistry = ActionRegistry(address(actionProxy));
        actionRegistryProxy = address(actionProxy);

        // Deploy GardenToken with proxy
        GardenToken gardenTokenImpl = new GardenToken(address(gardenAccountImpl));
        bytes memory gardenInitData = abi.encodeWithSelector(GardenToken.initialize.selector, multisig, address(0));
        ERC1967Proxy gardenProxy = new ERC1967Proxy(address(gardenTokenImpl), gardenInitData);
        gardenToken = GardenToken(address(gardenProxy));
        gardenTokenProxy = address(gardenProxy);

        // Deploy WorkResolver with proxy
        WorkResolver workResolverImpl = new WorkResolver(address(mockEAS), address(actionRegistry));
        bytes memory workInitData = abi.encodeWithSelector(WorkResolver.initialize.selector, multisig);
        ERC1967Proxy workProxy = new ERC1967Proxy(address(workResolverImpl), workInitData);
        workResolver = WorkResolver(payable(address(workProxy)));
        workResolverProxy = address(workProxy);

        // Deploy DeploymentRegistry with proxy
        DeploymentRegistry deploymentRegistryImpl = new DeploymentRegistry();
        bytes memory deploymentInitData = abi.encodeWithSelector(DeploymentRegistry.initialize.selector, multisig);
        ERC1967Proxy deploymentProxy = new ERC1967Proxy(address(deploymentRegistryImpl), deploymentInitData);
        deploymentRegistry = DeploymentRegistry(address(deploymentProxy));
        deploymentRegistryProxy = address(deploymentProxy);
    }

    /// @notice Test 1: Upgrade contracts and verify storage preservation
    function testUpgradePreservesStorage() public {
        // Setup initial state in ActionRegistry
        Capital[] memory capitals = new Capital[](2);
        capitals[0] = Capital.LIVING;
        capitals[1] = Capital.SOCIAL;

        string[] memory media = new string[](1);
        media[0] = "ipfs://original";

        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 30 days, "Original Action", "ipfs://instructions", capitals, media
        );

        // Store original values
        ActionRegistry.Action memory originalAction = actionRegistry.getAction(0);
        address originalOwner = actionRegistry.owner();

        // Deploy new implementation
        ActionRegistry newImpl = new ActionRegistry();

        // Upgrade to new implementation
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(newImpl));

        // Verify storage was preserved
        ActionRegistry.Action memory afterAction = actionRegistry.getAction(0);
        assertEq(afterAction.title, originalAction.title, "Action title should be preserved");
        assertEq(afterAction.startTime, originalAction.startTime, "Action start time should be preserved");
        assertEq(afterAction.endTime, originalAction.endTime, "Action end time should be preserved");
        assertEq(afterAction.instructions, originalAction.instructions, "Action instructions should be preserved");
        assertEq(actionRegistry.owner(), originalOwner, "Owner should be preserved");

        emit log_named_string("[PASS]", "Storage preserved after upgrade");
    }

    /// @notice Test 2: Only owner can authorize upgrades
    function testUpgradeAccessControl() public {
        // Deploy new implementation
        ActionRegistry newImpl = new ActionRegistry();

        // Attempt unauthorized upgrade
        vm.prank(unauthorized);
        vm.expectRevert("Ownable: caller is not the owner");
        actionRegistry.upgradeTo(address(newImpl));

        // Authorized upgrade should succeed
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(newImpl));

        emit log_named_string("[PASS] ActionRegistry", "Access control enforced");

        // Test GardenToken upgrade access control
        GardenToken newGardenImpl = new GardenToken(address(gardenAccountImpl));

        vm.prank(unauthorized);
        vm.expectRevert("Ownable: caller is not the owner");
        gardenToken.upgradeTo(address(newGardenImpl));

        vm.prank(multisig);
        gardenToken.upgradeTo(address(newGardenImpl));

        emit log_named_string("[PASS] GardenToken", "Access control enforced");

        // Test WorkResolver upgrade access control
        WorkResolver newWorkImpl = new WorkResolver(address(mockEAS), address(actionRegistry));

        vm.prank(unauthorized);
        vm.expectRevert("Ownable: caller is not the owner");
        workResolver.upgradeTo(address(newWorkImpl));

        vm.prank(multisig);
        workResolver.upgradeTo(address(newWorkImpl));

        emit log_named_string("[PASS] WorkResolver", "Access control enforced");
        emit log_named_string("[PASS]", "All upgrade access controls verified");
    }

    /// @notice Test 3: Storage gap usage allows adding new variables
    function testStorageGapUsage() public {
        // Current ActionRegistry has:
        // - _nextActionUID (1 slot)
        // - actionToOwner mapping (1 slot)
        // - idToAction mapping (1 slot)
        // - __gap (47 slots)
        // Total: 50 slots

        // In a real upgrade scenario, we would:
        // 1. Add new state variable
        // 2. Reduce gap by 1
        // 3. Deploy and upgrade

        // For this test, we verify the gap exists and has correct size
        // by checking storage layout doesn't conflict

        // Setup state
        Capital[] memory capitals = new Capital[](1);
        capitals[0] = Capital.MATERIAL;

        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 7 days, "Gap Test Action", "instructions", capitals, new string[](0)
        );

        // Deploy new implementation (same code, testing upgrade process)
        ActionRegistry newImpl = new ActionRegistry();

        vm.prank(multisig);
        actionRegistry.upgradeTo(address(newImpl));

        // Verify state still accessible
        ActionRegistry.Action memory action = actionRegistry.getAction(0);
        assertEq(action.title, "Gap Test Action");

        emit log_named_string("[PASS]", "Storage gap allows safe upgrades");
    }

    /// @notice Test 4: Upgrade with active state and users
    function testUpgradeWithActiveState() public {
        // Create active state: mint garden
        address[] memory gardeners = new address[](2);
        address[] memory operators = new address[](1);
        gardeners[0] = address(0x201);
        gardeners[1] = address(0x202);
        operators[0] = address(0x301);

        vm.prank(multisig);
        GardenToken.GardenConfig memory config = GardenToken.GardenConfig({
            communityToken: address(communityToken),
            name: "Active Garden",
            description: "Garden with active state",
            location: "Location",
            bannerImage: "banner.jpg",
            metadata: "",
            gardeners: gardeners,
            gardenOperators: operators
        });
        address gardenAddress = gardenToken.mintGarden(config);

        uint256 tokenId = 0;

        // Register multiple actions
        Capital[] memory capitals = new Capital[](1);
        capitals[0] = Capital.LIVING;

        vm.startPrank(multisig);
        for (uint256 i = 0; i < 3; i++) {
            actionRegistry.registerAction(
                block.timestamp,
                block.timestamp + 30 days,
                string(abi.encodePacked("Action ", uint2str(i))),
                string(abi.encodePacked("ipfs://instructions", uint2str(i))),
                capitals,
                new string[](0)
            );
        }
        vm.stopPrank();

        // Store state before upgrade
        address originalOwner = gardenToken.ownerOf(tokenId);
        GardenAccount garden = GardenAccount(payable(gardenAddress));
        string memory originalName = garden.name();
        bool wasGardener1 = garden.gardeners(gardeners[0]);
        bool wasGardener2 = garden.gardeners(gardeners[1]);
        bool wasOperator = garden.gardenOperators(operators[0]);

        // Upgrade GardenToken
        GardenToken newGardenImpl = new GardenToken(address(gardenAccountImpl));
        vm.prank(multisig);
        gardenToken.upgradeTo(address(newGardenImpl));

        // Upgrade ActionRegistry
        ActionRegistry newActionImpl = new ActionRegistry();
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(newActionImpl));

        // Verify all state preserved
        assertEq(gardenToken.ownerOf(tokenId), originalOwner, "Token owner preserved");
        assertEq(garden.name(), originalName, "Garden name preserved");
        assertEq(garden.gardeners(gardeners[0]), wasGardener1, "Gardener 1 preserved");
        assertEq(garden.gardeners(gardeners[1]), wasGardener2, "Gardener 2 preserved");
        assertEq(garden.gardenOperators(operators[0]), wasOperator, "Operator preserved");

        // Verify all actions preserved
        for (uint256 i = 0; i < 3; i++) {
            ActionRegistry.Action memory action = actionRegistry.getAction(i);
            assertEq(action.title, string(abi.encodePacked("Action ", uint2str(i))));
        }

        // Verify contracts still functional after upgrade
        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 7 days, "Post-Upgrade Action", "ipfs://new", capitals, new string[](0)
        );

        ActionRegistry.Action memory newAction = actionRegistry.getAction(3);
        assertEq(newAction.title, "Post-Upgrade Action");

        emit log_named_string("[PASS]", "Upgrade successful with active state");
    }

    /// @notice Test 5: Multiple sequential upgrades
    function testMultipleSequentialUpgrades() public {
        // Setup initial state
        Capital[] memory capitals = new Capital[](1);
        capitals[0] = Capital.SOCIAL;

        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 30 days, "Original Action", "ipfs://v1", capitals, new string[](0)
        );

        ActionRegistry.Action memory original = actionRegistry.getAction(0);

        // First upgrade
        ActionRegistry impl1 = new ActionRegistry();
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(impl1));

        // Add more state
        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 30 days, "After First Upgrade", "ipfs://v2", capitals, new string[](0)
        );

        // Second upgrade
        ActionRegistry impl2 = new ActionRegistry();
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(impl2));

        // Verify all state preserved through both upgrades
        ActionRegistry.Action memory afterUpgrade1 = actionRegistry.getAction(0);
        assertEq(afterUpgrade1.title, original.title);

        ActionRegistry.Action memory afterUpgrade2 = actionRegistry.getAction(1);
        assertEq(afterUpgrade2.title, "After First Upgrade");

        // Add more state after second upgrade
        vm.prank(multisig);
        actionRegistry.registerAction(
            block.timestamp, block.timestamp + 30 days, "After Second Upgrade", "ipfs://v3", capitals, new string[](0)
        );

        ActionRegistry.Action memory finalAction = actionRegistry.getAction(2);
        assertEq(finalAction.title, "After Second Upgrade");

        emit log_named_string("[PASS]", "Multiple sequential upgrades successful");
    }

    /// @notice Test 6: Upgrade cannot break initialization
    function testUpgradeCannotReinitialize() public {
        // Try to call initialize after deployment (should fail)
        vm.prank(multisig);
        vm.expectRevert("Initializable: contract is already initialized");
        actionRegistry.initialize(address(0x456));

        // Upgrade
        ActionRegistry newImpl = new ActionRegistry();
        vm.prank(multisig);
        actionRegistry.upgradeTo(address(newImpl));

        // Try to initialize after upgrade (should still fail)
        vm.prank(multisig);
        vm.expectRevert("Initializable: contract is already initialized");
        actionRegistry.initialize(address(0x789));

        // Verify owner unchanged
        assertEq(actionRegistry.owner(), multisig);

        emit log_named_string("[PASS]", "Cannot reinitialize after upgrade");
    }

    /// @notice Test 7: DeploymentRegistry upgrade preserves network configs
    function testDeploymentRegistryUpgrade() public {
        // Setup network configurations
        DeploymentRegistry.NetworkConfig memory config = DeploymentRegistry.NetworkConfig({
            eas: address(0x1000),
            easSchemaRegistry: address(0x1001),
            communityToken: address(communityToken),
            actionRegistry: address(actionRegistry),
            gardenToken: address(gardenToken),
            workResolver: address(workResolver),
            workApprovalResolver: address(0x1004)
        });

        uint256 chainId = 84_532; // Base Sepolia

        vm.prank(multisig);
        deploymentRegistry.setNetworkConfig(chainId, config);

        // Verify config stored
        (
            address eas,
            , // schemaRegistry
            address commToken,
            address actReg,
            , // gardTok
            , // workRes
                // workAppRes
        ) = deploymentRegistry.networks(chainId);

        assertEq(eas, config.eas);
        assertEq(actReg, address(actionRegistry));
        assertEq(commToken, address(communityToken));

        // Upgrade
        DeploymentRegistry newImpl = new DeploymentRegistry();
        vm.prank(multisig);
        deploymentRegistry.upgradeTo(address(newImpl));

        // Verify config preserved
        (
            address easAfter,
            , // schemaRegistryAfter
            address commTokenAfter,
            address actRegAfter,
            address gardTokAfter,
            , // workResAfter
                // workAppResAfter
        ) = deploymentRegistry.networks(chainId);

        assertEq(easAfter, config.eas);
        assertEq(actRegAfter, address(actionRegistry));
        assertEq(gardTokAfter, address(gardenToken));
        assertEq(commTokenAfter, address(communityToken));

        emit log_named_string("[PASS]", "DeploymentRegistry upgrade preserves configs");
    }

    /// @notice Helper function to convert uint to string
    function uint2str(uint256 _i) internal pure returns (string memory) {
        if (_i == 0) {
            return "0";
        }
        uint256 j = _i;
        uint256 len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint256 k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }
}
